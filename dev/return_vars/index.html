<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Demo: return variables · NMRHamiltonian.jl</title><meta name="title" content="Demo: return variables · NMRHamiltonian.jl"/><meta property="og:title" content="Demo: return variables · NMRHamiltonian.jl"/><meta property="twitter:title" content="Demo: return variables · NMRHamiltonian.jl"/><meta name="description" content="Documentation for NMRHamiltonian.jl."/><meta property="og:description" content="Documentation for NMRHamiltonian.jl."/><meta property="twitter:description" content="Documentation for NMRHamiltonian.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NMRHamiltonian.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../api/">Public API</a></li><li><a class="tocitem" href="../demo_code/">Demo: code walk-through</a></li><li class="is-active"><a class="tocitem" href>Demo: return variables</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Demo: return variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Demo: return variables</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/main/docs/src/return_vars.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Demo:-return-variables"><a class="docs-heading-anchor" href="#Demo:-return-variables">Demo: return variables</a><a id="Demo:-return-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Demo:-return-variables" title="Permalink"></a></h1><p>Run the code on the <code>Demo: code walk-through</code> first.</p><p>We&#39;ll explore the various field names of the return variables for the simulation. We&#39;ll set look at the first compound (i.e., <code>n = 1</code>) and the first spin system (i.e., <code>i = 1</code>) for this demo. In Julia, set these variables:</p><pre><code class="language-julia hljs">n = 1
i = 1</code></pre><h3 id="Resonance-components-result-for-the-n-th-compound-entry,-As[n]"><a class="docs-heading-anchor" href="#Resonance-components-result-for-the-n-th-compound-entry,-As[n]">Resonance components result for the n-th compound entry, <code>As[n]</code></a><a id="Resonance-components-result-for-the-n-th-compound-entry,-As[n]-1"></a><a class="docs-heading-anchor-permalink" href="#Resonance-components-result-for-the-n-th-compound-entry,-As[n]" title="Permalink"></a></h3><p>First, we find out what data type the <code>As</code> variable is. </p><pre><code class="language-julia hljs">typeof(As)</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">Vector{SHType{Float64}}</code></pre><p>Next, we display the list of field names for the variable <code>As[n]</code>, which corresponds to the 1-st compound entry.</p><pre><code class="language-julia hljs">ns = propertynames(As[n])</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">(:αs, :Ωs, :Δc, :parts, :Δc_bar, :N_spins_sys, :fs, :SW, :ν_0ppm)</code></pre><p>Let&#39;s see their respective data types:</p><pre><code class="language-julia hljs">collect( typeof( getfield(As[n], field_name) ) for field_name in ns )</code></pre><p>This should show up in the REPL, and we added additional comments to show what the nested arrays index.</p><pre><code class="nohighlight hljs">9-element Vector{DataType}:
 Vector{Vector{Float64}} # αs
 Vector{Vector{Float64}} # Ωs
 Vector{Vector{Vector{Float64}}} # Δc
 Vector{Vector{Vector{Int64}}} # part
 Vector{Vector{Vector{Float64}}} # Δc_bar
 Vector{Int64} # N_spins_sys
 Float64 # fs, sampling frequency (in Hz) of the spectrometer used for this simulation (i.e., it is an input to the simulation, returned for book keeping).
 Float64 # SW, the spectral window (in ppm) of the spectrometer used for this simulation.
 Float64 # ν_0ppm, the 0 ppm resonance frequency used for this simulation.</code></pre><p>Some of the field names are described below:</p><ul><li><code>αs[i][l]</code>: resonance intensities for the i-th spin system, l-th resonance component. The intensities are relative to the number of nuclei for the n-th compound entry.</li><li><code>Ωs[i][l]</code>: resonance frequencies for the i-th spin system, l-th resonance component. This is a radial frequency, which has units of radians. Divide by 2π to convert to Hz.</li></ul><p>NMRHamiltonian scales <code>αs</code> for a given n-th entry such that we should recover approximately the number of nuclei if we sum over the relative intensities. For example: </p><pre><code class="language-julia hljs">sum(As[1].αs[1])</code></pre><p>gives</p><pre><code class="nohighlight hljs">4.994790368138611</code></pre><p>This number approaches 5 as <code>relative_α_threshold</code> is set to approach zero, the number of nuclei for the <code>n == 1</code> compound entry of this demo, which is <code>L-Glutamine</code>. However, setting <code>relative_α_threshold = 0.0</code> incurs significant computational burden, as every resonance component is kept, even if it has a tiny intensity. In practice, we recommend leaving <code>relative_α_threshold == 0.01</code> or some other small number, but keep in mind that the sum of the relative intensities would not be exactly equal to the number of nuclei used to assemble the Hamiltonian.</p><ul><li><code>Δc[i][l][j]</code>: order of coherence for the i-th spin system, l-th resonance component, and j-th ME-modulo nuclei index. The set of 1-D arrays <code>Δc[i]</code> is the input set we pass to convex clustering to construct a partition. You can use your own clustering/partition construction algorithm; just overwrite <code>Δc_bar[i]</code> and <code>part[i]</code> accordingly with your results. </li></ul><ul><li><p><code>part</code>: a part is an element of a partition in combinatorics literature terminology. <code>part[i][l]</code> contains the resonance component indices (the <code>l</code> index from <code>Δc</code>) that belong in the part for the i-th spin system, j-th part. In NMRHamiltonian, a part of a spin system is called a resonance group, as it is a set of resonance components that share a similar degrees of freedom.</p></li><li><p><code>Δc_bar[i][k][j]</code>: representative order of coherence for the i-th spin system, k-th resonance group, and j-th ME-modulo nuclei index. The number of <code>k</code> index values is the number of parts that convex clustering returned.</p></li><li><p><code>N_spins_sys[i]</code>: the number of nuclei in the i-th spin system. These are not ME_modulo nuclei. This is used for normalization purposes for finalizing <code>αs</code>.</p></li></ul><h3 id="Spin-system-information-for-the-n-th-compound-entry,-MSPs[n]"><a class="docs-heading-anchor" href="#Spin-system-information-for-the-n-th-compound-entry,-MSPs[n]">Spin system information for the n-th compound entry, <code>MSPs[n]</code></a><a id="Spin-system-information-for-the-n-th-compound-entry,-MSPs[n]-1"></a><a class="docs-heading-anchor-permalink" href="#Spin-system-information-for-the-n-th-compound-entry,-MSPs[n]" title="Permalink"></a></h3><p>First, we find out what data type the <code>MSPs</code> variable is. </p><pre><code class="language-julia hljs">typeof(MSPs)</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">Vector{MoleculeSpinSystem{Float64}}</code></pre><p>Next, we display the list of field names for the variable <code>Rs[n][i]</code>, which corresponds to the convex clustering results for the first compound entry, first spin system.</p><pre><code class="language-julia hljs">ns = propertynames(MSPs[n])</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">(:spin_systems, :singlet_intensities, :singlet_frequencies)</code></pre><ul><li><p><code>spin_systems</code>: Discussed shortly.</p></li><li><p><code>singlet_intensities[m]</code>: The m-th singlet intensity of the n-th compound entry.</p></li><li><p><code>singlet_frequencies[m]</code>: The m-th singlet (radial) frequency (in radians) of the n-th compound entry.</p></li></ul><h3 id="Hamiltonian-for-the-n-th-compound-entry,-i-th-spin-system,-MSPs[n].spin_system[i]"><a class="docs-heading-anchor" href="#Hamiltonian-for-the-n-th-compound-entry,-i-th-spin-system,-MSPs[n].spin_system[i]">Hamiltonian for the n-th compound entry, i-th spin system, <code>MSPs[n].spin_system[i]</code></a><a id="Hamiltonian-for-the-n-th-compound-entry,-i-th-spin-system,-MSPs[n].spin_system[i]-1"></a><a class="docs-heading-anchor-permalink" href="#Hamiltonian-for-the-n-th-compound-entry,-i-th-spin-system,-MSPs[n].spin_system[i]" title="Permalink"></a></h3><p>First, we find out what data type the <code>MSPs[n].spin_systems[i]</code> variable is. </p><pre><code class="language-julia hljs">typeof(MSPs[n].spin_systems[i])</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">NMRHamiltonian.SpinSystem{Float64}</code></pre><p>Next, we display the list of field names for the variable <code>MSPs[n].spin_systems[i]</code>, which corresponds to the convex clustering results for the first compound entry, first spin system.</p><pre><code class="language-julia hljs">ns = propertynames(MSPs[n].spin_systems[i])</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">(:intensities, :frequencies, :H, :coherence_mat, :coherence_state_pairs, :states, :partial_quantum_numbers, :quantum_numbers, :coherence_tol)</code></pre><p>Let&#39;s see their respective data types:</p><pre><code class="language-julia hljs">collect( typeof( getfield(MSPs[n].spin_systems[i], field_name) ) for field_name in ns )</code></pre><p>This should show up in the REPL, and we added additional comments to show what the nested arrays index.</p><pre><code class="nohighlight hljs">9-element Vector{DataType}:
 Vector{Float64} (alias for Array{Float64, 1}) # intensities
 Vector{Float64} (alias for Array{Float64, 1}) # frequencies
 NMRHamiltonian.Hamiltonian{Float64} # H
 Matrix{Float64} (alias for Array{Float64, 2}) # coherence_mat
 Vector{Tuple{Int64, Int64}} (alias for Array{Tuple{Int64, Int64}, 1}) # coherence_state_pairs
 Vector{Int64} (alias for Array{Int64, 1}) # states
 Vector{Vector{Float64}} (alias for Array{Array{Float64, 1}, 1}) # partial_quantum_numbers
 Vector{Float64} (alias for Array{Float64, 1}) # quantum_numbers
 Float64 # coherence_tol</code></pre><ul><li><p><code>intensities</code>: These are all the resonance intensities that passed the (-1)-quantum coherence condition (within a numerical tolerance of <code>coherence_tol</code>). The <code>αs</code> intensities were created from intensities.</p></li><li><p><code>frequencies</code>: Similar to <code>intensities</code>, but for resonance (radial) frequencies, in radians.</p></li><li><p><code>H</code>: information for the Hamiltonian matrix. The <code>H.matrix</code> is the Hamiltonian matrix. <code>H.contributions</code> is a 1-D array of two matrices that sum to <code>H.matrix</code>, each of the matrices corresponds to a term in the Hamiltonian equation in our manuscript. The <code>H.eigenvalues</code> and <code>H.eigenvectors</code> are the eigenpairs of <code>H.matrix</code>.</p></li><li><p><code>coherence_mat</code>: this is the order of coherence as computed using the z-axis spin angular momentum.</p></li><li><p><code>coherence_state_pairs</code>: this is the eigenstate pairs (sometimes denoted by <code>{(r,s)}</code> in our manuscript) that corresponds to each resonance component in <code>intensities</code> and <code>frequencies</code>.</p></li><li><p><code>states</code>: the unique states in <code>coherence_state_pairs</code>.</p></li><li><p><code>partial_quantum_numbers</code>: the contributions to the quantum number of each state in <code>states</code>. One contribution from each quantum sub-system, where each sub-system is a ME-modulo nuclei index. These generate the order of coherence features <code>Δc</code>.</p></li><li><p><code>quantum_numbers</code>: the quantum numbers of an eigenstate, used to determine if a state-pair from <code>coherence_state_pairs</code> satisfies the (-1)-quantum coherence condition (within a numerical tolerance of <code>coherence_tol</code>). If it does, the state-pair creates a valid resonance component, and its intensity and frequency is computed and stored as an element of <code>intensities</code> and <code>frequencies</code>, respectively.</p></li></ul><h3 id="Physical-chemistry-parameters-for-the-n-th-compound-entry,-Phys[n]"><a class="docs-heading-anchor" href="#Physical-chemistry-parameters-for-the-n-th-compound-entry,-Phys[n]">Physical chemistry parameters for the n-th compound entry, <code>Phys[n]</code></a><a id="Physical-chemistry-parameters-for-the-n-th-compound-entry,-Phys[n]-1"></a><a class="docs-heading-anchor-permalink" href="#Physical-chemistry-parameters-for-the-n-th-compound-entry,-Phys[n]" title="Permalink"></a></h3><p>First, we find out what data type the <code>Phys[n]</code> variable is. </p><pre><code class="language-julia hljs">typeof(Phys[n])</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">NMRHamiltonian.PhysicalParamsType{Float64}</code></pre><p>Next, we display the list of field names for the variable <code>Phys[n]</code>, which corresponds to the convex clustering results for the first compound entry, first spin system.</p><pre><code class="language-julia hljs">ns = propertynames(Phys[n])</code></pre><p>This should show up in the REPL.</p><pre><code class="nohighlight hljs">(:H_IDs, :H_inds_sys, :cs_sys, :H_inds_singlets, :cs_singlets, :J_inds_sys, :J_inds_sys_local, :J_vals_sys, :ME)</code></pre><p>Let&#39;s see their respective data types:</p><pre><code class="language-julia hljs">collect( typeof( getfield(Phys[n], field_name) ) for field_name in ns )</code></pre><p>This should show up in the REPL, and we added additional comments to show what the nested arrays index.</p><pre><code class="nohighlight hljs">9-element Vector{DataType}:
 Vector{Int64} # H_IDs
 Vector{Vector{Int64}} # H_inds_sys
 Vector{Vector{Float64}} # cs_sys
 Vector{Vector{Int64}} # H_inds_singlets
 Vector{Float64} # cs_singlets
 Vector{Vector{Tuple{Int64, Int64}}} # J_inds_sys
 Vector{Vector{Tuple{Int64, Int64}}} # J_inds_sys_local
 Vector{Vector{Float64}} # J_vals_sys
 Vector{Vector{Vector{Int64}}} # ME</code></pre><ul><li><p><code>H_IDs</code>: The nuclei labels parsed from the physical chemistry file for the n-th compound entry.</p></li><li><p><code>H_inds_sys[i]</code>: The nuclei from a re-labelled <code>H_IDs</code> that are in the i-th spin system. The re-label starts from 1, and increments by 1.</p></li><li><p><code>cs_sys[i]</code>: The chemical shifts (in units ppm) that corresponds to the nuclei in <code>H_inds_sys[i]</code>, for the i-th spin system.</p></li><li><p><code>H_inds_singlets</code>: The nuclei from a re-labelled <code>H_IDs</code> that generate singlet spin systems.</p></li><li><p><code>cs_singlets</code>: The chemical shifts (in units ppm) that corresponds to the nuclei in <code>H_inds_singlets</code>.</p></li><li><p><code>J_inds_sys[i]</code>: Pairs of nuclei from <code>H_inds_sys[i]</code> such that each pair has a J-coupling value for the i-th spin system.</p></li><li><p><code>J_inds_sys_local[i]</code>: This is a version of <code>J_inds_sys[i]</code> but the nuclei indices are re-labelled to start from 1, i.e. this is a re-labelling of the nuclei for the i-th spin system.</p></li><li><p><code>J_vals_sys</code>: J-coupling values in Hz, corresponds to the nuclei in <code>J_inds_sys[i]</code> and <code>J_inds_sys_local[i]</code>.</p></li><li><p><code>ME[i][m]</code>: The nuclei indices from a re-labelled <code>H_IDs</code> (so that it starts from 1, increments by 1) for the m-th non-singleton ME-modulo nuclei index in the i-th spin system. This means <code>ME[i][m]</code> contains some nuclei labels that together form the m-th set of nuclei such that it contains only nuclei that are magnetically equivalent to each other, and this m-th set of nuclei is the largest possible set. Non-singleton means that <code>ME[i][m]</code> does not include nucleus that are not magnetically equivalent to anyone else; any nucleus is magnetically equivalent to itself, and we exclude it to be in <code>ME[i][m]</code>. For example, if <code>Phys[n].ME[i]</code> contains </p></li></ul><pre><code class="nohighlight hljs">2-element Vector{Vector{Int64}}:
 [7, 5, 6] # assign to j == 1
 [1, 2, 3] # assign to j == 2.
 # The other values of j&#39;s are assigned according to ascending numerical value of whatever nuclei labels are left in this spin system.</code></pre><p>then it means the n-th compound entry, i-th spin system has two non-singleton magnetically equivalent set of nuclei. The first set of nuclei is nuclei <code>{7,5,6}</code> and the second set is nuclei <code>{1,2,3}</code>. If there are 8 nuclei for this compound entry, then nuclei 4 and 8 are both not magnetically equivalent to any other nuclei that isn&#39;t itself. The ME-module index <code>j</code> for this spin system would be <code>{1,2,3,4}</code>, with <code>j == 1</code> representing nuclei <code>{7,5,6}</code>, <code>j == 2</code> representing nuclei <code>{1,2,3}</code>, <code>j == 3</code> representing nucleus <code>4</code>, <code>j == 4</code> representing nucleus <code>8</code>.</p><h3 id="Store-simulated-variables"><a class="docs-heading-anchor" href="#Store-simulated-variables">Store simulated variables</a><a id="Store-simulated-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Store-simulated-variables" title="Permalink"></a></h3><p>JSON: in this demo, we use the <a href="https://github.com/quinnj/JSON3.jl">JSON3.jl</a> library for loading JSON. Please make sure it is installed before running the following code.</p><pre><code class="nohighlight hljs"># store.
file_name = &quot;test.json&quot;
S = NMRHamiltonian.serializemixture(As)
NMRHamiltonian.saveasJSON(file_name, S)

# load.
import JSON 3
file_path = file_name
json_string = read(file_path)
W = JSON3.read(json_string)</code></pre><p>You can also use <a href="https://github.com/JuliaIO/BSON.jl">BSON.jl</a>.</p><pre><code class="nohighlight hljs"># store.
file_name = &quot;test.bson&quot;
S = NMRHamiltonian.serializemixture(As)
BSON.bson(file_name, S)

# load.
W = BSON.load(file_name)</code></pre><p>A round-trip test routine is in the <code>test</code> folder of the NMRHamiltonian repository. See the functions <code>roundtripJSON()</code> and <code>roundtripBSON()</code> in that folder for more details on the test.</p><p>An alternative method to serialize data is with the Julia Base <code>Serialization</code> library. My understanding is that compatibility is not guaranteed between Julia versions, so it should be used for short-term storage.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../demo_code/">« Demo: code walk-through</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Monday 13 November 2023 17:08">Monday 13 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
