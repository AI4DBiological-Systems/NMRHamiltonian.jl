# Simulate the resonance intensities α and resonance frequencies Ω for a few molecules

Work in progress.


In this example, we provide NMRHamiltonian.jl with the following simulated spectrometer parameters to simulate α and Ω: 
- `fs` the sampling frequency in Hz,
- `SW` the spectral window in ppm,
- `ν_0ppm` the frequency of the 0 ppm resonance component in the simulated data, in Hz.
The simulated quantities returned by NMRHamiltonian.jl are the resonance intensities and frequencies, which are α and Ω, respectively, in our publication. 

```{julia}
import NMRHamiltonian

using LinearAlgebra
using FFTW
import PyPlot
import JSON
```

The following are configuration path variables. A default set of these are provided in NMRPublicData. Replace these paths with the ones on your local machine.
```{julia}

```

The following are experiment setting parameters taken from the BMRB 700 MHz 20 mM glucose experiment. Alternatively, obtain these values from loading an actual NMR experiment using NMRDataSetup.jl.
```{julia}
molecule_entries = ["L-Methionine"; "L-Phenylalanine"; "DSS"; "Ethanol"; "L-Isoleucine"]

fs = 14005.602240896402 # sampling frequency in Hz.
SW = 20.0041938620844 # spectral window in ppm.
ν_0ppm = 10656.011933076665 # 0 ppm frequency for this simulation.
```

The following are simulation parameters. NMRHamiltonian.jl keep resonance components that satisfy the following:
1) have a -1 +/- `coherence_tol` quantum coherence, and 2) have a resonance intensity (α in our publication) >= `relative_α_threshold`.
`Δc_partition_radius` is used to group together resonance components, as described in our publication.
```{julia}
coherence_tol = 1e-2 # resonances are pairs of eigenvalues of the Hamiltonian that have quantum numbers that differ by -1. This is the tolerance away from -1 that is allowed.
relative_α_threshold = 0.05 # resonances with relative amplitude less than this factor compared to the maximum resonance in the spin group will be removed. Set to 0.0 to see every single resonance component.
Δc_partition_radius = 0.3 # determines how many resonances get grouped together. Larger number means less groups and thus more resonances per group.
```

Extract the chemical shift and J-coupling values from configuration files path information in `dict_molecule_to_filename`. The result is store in `Phys`, which is an array of structure objects with datatype `PhysicalParamsType`.

```{julia}
Phys = NMRHamiltonian.getphysicalparameters(molecule_entries,
    Float64,
    H_params_path,
    molecule_mapping_file_path;
    unique_cs_atol = 1e-6)
```

To list the field names of the structure, use `propertynames()` on an element of `Phys`. Each element corresponds to its entry in `molecule_entries`. We focus on the second molecule for example:
```{julia}
println("Order of molecules:", molecule_entries)

molecule_select = 2
p_name = molecule_entries[molecule_select]
p = Phys[molecule_select]
println("propertynames(): ", propertynames(p))
```

For the molecule `p_name`, its chemical shift and J-coupling values are stored in the structure `p`, of datatype `PhysicalParamsType`.
`H_IDs` contain the nuclei (hydrogen in 1D 1H NMR) ID labels from the configuration file corresponding to `p_name`.
The nuclei that belong in a non-singlet spin system are stored in `H_inds_sys` (their ID labels) and `cs_sys` (their chemical shifts). The nuclei that belong in a singlet spin system are stored in `H_inds_singlets` (their ID labels), `cs_singlets` (their chemical shifts). The ID labels in `H_inds_sys` and `H_inds_singlets` are re-numbered to start at 1, such that the first ID label for `H_IDs` becomes ID 1. For example,
```{julia}
nuclei
nucleus
println("nucleus $(p.H_IDs[1]) in configuration file is ID 1 in p.H_inds_singlets or p.H_inds_sys,")
println("nucleus $(p.H_IDs[2]) in configuration file is ID 2 in p.H_inds_singlets or p.H_inds_sys, etc.")
```
We refer `H_IDs` as the configuration file nucleus ID, and `H_inds_sys` and `H_inds_singlets` as the nucleus index ID for the rest of this example. The index IDs are used in the internal workings of NMRHamiltonian.jl. The configuration file IDs are useful to relate the simulated quantities to the ID information from the configuration file, which could be a particular ordering of the nucleus from a scientific journal or database.

There can be multiple non-singlet spin systems for a molecule, so `H_inds_sys` and `cs_sys` are nested 1D arrays. The first index slot of the nested array address a non-singlet spin system of the molecule, and the second index address a nucleus from the addressed spin system. For example, the following prints the nucleus ID and its chemical shift for the third nucleus in the second spin system:
```{julia}
sys_select = 2
nucleus_select = 3
println("system $(sys_select), nucleus $(nucleus_select), ID:", p.H_inds_sys[sys_select][nucleus_select])
println("system $(sys_select), nucleus $(nucleus_select), chemical shift:", p.cs_sys[sys_select][nucleus_select])
```

`J_inds_sys` contain the pair-wise coupling connectivity between a pair of nucleui, i.e. it describes the J-coupling connections for each spin system of the molecule. In `J_inds_sys` and `J_inds_sys_local`, each pairing for a J-coupling connection is a tuple of two `H_inds_sys` nuclei. `J_inds_sys_local` is a re-numbered version of `J_inds_sys`. This is because NMRHamiltonian.jl simulates each spin system separately, so a re-numbering to local nuclei for a given spin system is used in its internal workings. The corresponding J-coupling values are stored in `J_vals_sys`. The quantities `J_inds_sys`, `J_inds_sys_local`, `J_vals_sysuse` a nested array similar to `cs_sys`. The first index address a non-singlet spin system of the molecule, and the second index address a J-coupling pair within the spin system. For example, the following prints all the J-coupling nucleus IDs and J-coupling values for a given non-singlet spin system.
```{julia}
sys_select = 2
println("system $(sys_select), J-coupling nucleus pairs:", p.J_inds_sys[sys_select])
println("system $(sys_select), corresponding J-coupling values:", p.J_vals_sys[sys_select])
```

`ME` contain information about magnetic equivalence of a molecule. From an algorithmic perspective, NMR nuclei magnetic equivalence is a grouping of nuclei within a spin system that obeys some conditions; see NMR textbook references or our publication for more information. The `ME` field name is a 3-times nested array. The first index address the non-singlet spin system, the second address the magnetic equivalence group within the addressed spin system, and the third index address a nucleus within the addressed magnetic equivalence group. For example, we see that there are two magnetic equivalent groups in the first spin system of Ethanol:
```{julia}
ethanol_index = 4
println("Overall ME for ethanol:", Phys[ethanol_index].ME)
println()

inds1 = Phys[ethanol_index].ME[1][1]
println("The nuclei index ID for the first magnetic equivalence group in the first (and only) spin system of ethanol:", inds1)
println("Its corresponding configuration file nuclei IDs:", Phys[ethanol_index].H_IDs[inds1])
println()

inds2 = Phys[ethanol_index].ME[1][2]
println("The nuclei index ID for the second magnetic equivalence group in the first (and only) spin system of ethanol:", inds2)
println("Its corresponding configuration file nuclei IDs:", Phys[ethanol_index].H_IDs[inds2])
```

The chemical shift and nuclei information for singlets can be acessed in a similar manner to the non-singlet spin systems. There are no J-coupling between singlets.
```{julia}
DSS_select = 3 # DSS is the third entry in molecule_entries.

inds = Phys[DSS_select].H_inds_singlets
println("The singlet index nuclei IDs: ", inds)
println("The singlet configuration file nuclei IDs", Phys[DSS_select].H_IDs[inds])
println("Corresponding chemical shifts:", Phys[DSS_select].cs_singlets)
```

The following example creates a `deepcopy` of `Phys`, called `Phys_mod`, and increases the copy's chemical shift of the second nucleus of the first non-singlet spin system. We also decrease the chemical shift of the first singlet of the DSS molecule; this is originally the 0 ppm singlet in the configuration file we loaded. Using a [deepcopy()](https://docs.julialang.org/en/v1/base/base/#Base.deepcopy) ensures the arrays in the resultant copied object does not share the same pointer address as the arrays in the original object. This allows one to modify `Phys_mod` without modifying `Phys`.
```{julia}
Phys_mod = deepcopy(Phys)

molecule_select = 1
sys_select = 2
nucleus_select = 3
Phys_mod[molecule_select].cs_sys[sys_select][nucleus_select] += 0.1

Phys_mod[DSS_select].cs_singlets[1] -= 0.1
```



We now pass the physical parameters of the molecules in `Phys` to the spin Hamiltonian simulator. One can pass `Phys_mod` or another copied version of Phys if a different physical chemistry parameter profile than the one in `Phys` is desired.
```{julia}
As = NMRHamiltonian.simulate(molecule_entries,
    fs, SW, ν_0ppm,
    Phys;
    config_path = SH_config_path,
    coherence_tol = coherence_tol,
    relative_α_threshold = relative_α_threshold,
    Δc_partition_radius = Δc_partition_radius)
```

Talk about the return types of As.

To generate a simulated spectrum, we need to provide the T-2 decay parameter. We now walk through this procedure to visualize a particular spin system of a particular molecule.

### visualize a target molecule and spin group, given a T-2 decay parameter.
λ0 = 3.4 # T-2 decay parameter.
molecule_select = 2
spin_system_select = 1
ppm_offset = 0.2 # for display padding.
N_viz = 50000

a = As[molecule_select].αs[spin_system_select]
F = As[molecule_select].Ωs[spin_system_select]

hz2ppmfunc = uu->(uu - ν_0ppm)*SW/fs
ppm2hzfunc = pp->(ν_0ppm + pp*fs/SW)

ΩS_ppm = hz2ppmfunc.( F ./ (2*π) )
ΩS_ppm_sorted = sort(ΩS_ppm)

u_min = ppm2hzfunc(ΩS_ppm_sorted[1] - ppm_offset)
u_max = ppm2hzfunc(ΩS_ppm_sorted[end] + ppm_offset)

P_min = hz2ppmfunc(u_min)
P_max = hz2ppmfunc(u_max)

P = LinRange(P_min, P_max, N_viz)
U = ppm2hzfunc.(P)
U_rad = U .* (2*π)

# absorption Lorentzian.

function evalzerophasecl1Darray(u_rad, αs::Vector{T}, Ωs::Vector{T}, λ::T)::Complex{T} where T <: AbstractFloat

    out = zero(Complex{T})
    for l = 1:length(αs)
        out += evalzerophaseclpartitionelement(u_rad, αs[l], Ωs[l], λ)
    end

    return out
end

function evalzerophaseclpartitionelement(r,
    α::T, Ω::T, λ::T)::Complex{T} where T <: AbstractFloat

    out = α/(λ+im*(r-Ω))

    return out
end

q = uu->evalzerophasecl1Darray(uu, a, F, λ0)
q_U = q.(U_rad)

# plot.
PyPlot.figure(fig_num)
fig_num += 1

PyPlot.plot(P, q_U)
PyPlot.gca().invert_xaxis()

PyPlot.legend()
PyPlot.title("spectrum of $(molecule_entries[molecule_select]), spin system $(spin_system_select)")
