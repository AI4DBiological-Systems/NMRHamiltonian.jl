var documenterSearchIndex = {"docs":
[{"location":"api/#Function-References","page":"Public API","title":"Function References","text":"","category":"section"},{"location":"api/#Physical-chemistry-parameters-of-compounds","page":"Public API","title":"Physical chemistry parameters of compounds","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"PhysicalParamsType","category":"page"},{"location":"api/#NMRHamiltonian.PhysicalParamsType","page":"Public API","title":"NMRHamiltonian.PhysicalParamsType","text":"struct PhysicalParamsType{T}\n- H_IDs::Vector{Int}\n- H_inds_sys::Vector{Vector{Int}}\n- cs_sys::Vector{Vector{T}}\n- H_inds_singlets::Vector{Vector{Int}}\n- cs_singlets::Vector{T}\n- J_inds_sys::Vector{Vector{Tuple{Int,Int}}}\n- J_inds_sys_local::Vector{Vector{Tuple{Int,Int}}}\n- J_vals_sys::Vector{Vector{T}}\n- ME::Vector{Vector{Vector{Int}}}\n\nThe chemical shift and J-coupling values with respect to nuclei labels for a molecule. Based on this information, an algorithm is used to create magnetic equivalence information in ME.\n\nDetails ≡≡≡≡≡≡≡≡\n\nH_IDs::Vector{Int}\n\nNumerical (positive integer) numbering of nuclei for a molecule entry. This numbering is taken from a file, so it is not guaranteed to be consecutive nor start at 1.\n\nH_inds_sys::Vector{Vector{Int}}\n\nNested list of nuclei labels in consecutive positive integers, which NMRHamiltonian refers to as nuclei indices. The element at [i] is a list of nuclei indices for the i-th non-singlet spin system.\n\ncs_sys::Vector{Vector{T}}\n\nNested list of non-singlet chemical shifts. The element at [i] is a list of chemical shift values for the i-th non-singlet spin system.\n\nH_inds_singlets::Vector{Vector{Int}}\n\nNested list of nuclei labels in consecutive positive integers, which NMRHamiltonian refers to as nuclei indices. The element at [i] is a list of nuclei indices that contribute to the same i-th singlet.\n\ncs_singlets::Vector{T}\n\nList of chemical shift values for singlets.\n\nJ_inds_sys::Vector{Vector{Tuple{Int,Int}}}\n\nNested list of pairs of nuclei indices. The element at [i] is a list of J-coupling indices for the i-th non-singlet spin system. J-coupling index is a pair of nuclei indices.\n\nJ_inds_sys_local::Vector{Vector{Tuple{Int,Int}}}\n\nNested list of pairs of nuclei indices. The element at [i] is a list of J-coupling indices for the i-th non-singlet spin system. J-coupling index is a pair of nuclei indices. The nuclei indices are re-numbered to start from 1 for each spin system, which NMRHamiltonian refers to as local nuclei indices.\n\nInternally, spin Hamiltonian matrices for each spin system use this particular indexing scheme in their construction.\n\nJ_vals_sys::Vector{Vector{T}}\n\nNested list of J-coupling values. The element at [i] is a list J-coupling values for the i-th non-singlet spin system.\n\nME::Vector{Vector{Vector{Int}}}\n\nThe element at [i][k] is a list of nuclei indices that are magnetically equivalent. The indices in this list collectively make up the k-th magnetically equivalent group in the i-th spin system. The nuclei indices are re-numbered to start from 1 for each spin system, which NMRHamiltonian refers to as local nuclei indices.\n\nNote that NMRHamiltonian defines magnetically equivalent groups must have two or more nuclei, and these equivalence are determined only based on the J-coupling and chemical shift values provided in the corresponding file for the molecule entry at hand.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"getphysicalparameters","category":"page"},{"location":"api/#NMRHamiltonian.getphysicalparameters","page":"Public API","title":"NMRHamiltonian.getphysicalparameters","text":"getphysicalparameters(\n    ::Type{T},\n    target_entries::Vector{String},\n    H_params_path::String,\n    molecule_mapping_file_path;\n    unique_cs_atol::T = convert(T, 1e-6),\n) where T <: AbstractFloat\n\nAssemble the J-coupling and chemical shift values from JSON files for the specified molecules.\n\nNomenclature\n\nOne set of J-coupling and one set of chemical shift values for a molecule is what NMRHamiltonian.jl calls a molecule entry.\n\nIt is common to see different J-coupling values of the same molecule reported in literature for similar experimental conditions.  NMRHamiltonian.jl requires one to record each instance as separate molecule entry.\n\nEvery molecule entry is recorded as a separate JSON file with some arbitrary file name the data collector wants to use. An additional name-mapping JSON file is needed to translate what the NMRHamiltonian.jl user wants to label the entries to what is the data collector chose to name the JSON files. The name-mapping JSON file is likely to require manual set up.\n\nInputs\n\n::Type{T}       – The AbstractFloat datatype to use for storing floating-point data. A viable input here is Float64, which specifies double precision floating-point numbers are to be used.\ntarget_entries  – list of molecule entry names.\nH_params_path   – path to the directory that contain the J-coupling and chemical shift JSON files. Each file corresponds to one entry of a molecule, and has a set of chemical shifts and J-coupling information in the JSON dictionary format.   ID1 and ID2 are JSON dictionary keys that specify the spin nucleus label for J-coupling values, and ID is the nucleus label for chemical shift values. The following is an example of the JSON format for a L-Histidine entry:\n\n{\n       \"J-coupling\": [\n                       {\n                            \"ID2\": 13,\n                            \"ID1\": 12,\n                          \"value\": -15.350518\n                       },\n                       {\n                            \"ID2\": 16,\n                            \"ID1\": 12,\n                          \"value\": 7.63377\n                       },\n                       {\n                            \"ID2\": 16,\n                            \"ID1\": 13,\n                          \"value\": 5.029267\n                       }\n                     ],\n   \"chemical shift\": [\n                       {\n                          \"value\": 3.18747,\n                             \"ID\": 12\n                       },\n                       {\n                          \"value\": 3.26837,\n                             \"ID\": 13\n                       },\n                       {\n                          \"value\": 7.14078,\n                             \"ID\": 14\n                       },\n                       {\n                          \"value\": 8.02487,\n                             \"ID\": 15\n                       },\n                       {\n                          \"value\": 3.9967,\n                             \"ID\": 16\n                       }\n                     ]\n}\n\nmolecule_mapping_file_path   – the files in H_params_path might not be named in a manner for the user to know which molecule entry corresponds to which JSON file. Therefore, the user should further define a single JSON file that encodes this mapping.   Example: if the file bmse000976_simulation_1.json corresponds to the molecule entry \"L-Histidine\" and the file Histidine_Govindaraju_2000.json corresponds to the molecule entry \"L-Histidine - Govindaraju\", and suppose the user only wants to target these two entries, i.e. target_entries contain only these two entries. Then the following entry-filename-mapping JSON file should be used, and molecule_mapping_file_path should be the path to this entry-filename-mapping file.\n\n{\n    \"L-Histidine\": {\n        \"notes\": \"http://gissmo.bmrb.io/entry/bmse000976/simulation_1\",\n       \"file name\": \"bmse000976_simulation_1.json\"\n    },\n    \"L-Histidine - Govindaraju\": {\n        \"notes\": \"https://pubmed.ncbi.nlm.nih.gov/10861994/\",\n       \"file name\": \"Histidine_Govindaraju_2000.json\"\n    }\n}\n\nOptional inputs\n\nunique_cs_atol   – Two chemical shift values in the same JSON file are assigned the same chemical shift value to both nuclei if the two values in the file are less than unique_cs_atol.\n\nOutputs\n\nPhys::Vector{PhysicalParamsType{Float64}    – list of the data type PhysicalParamsType that contain chemical shift and J-coupling information for each of the molecule entries in target_entries.\ndict_molecule_to_filename                   – the dictionary that maps molecule entries to meta information such as their corresponding JSON filenames\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"extractcs","category":"page"},{"location":"api/#NMRHamiltonian.extractcs","page":"Public API","title":"NMRHamiltonian.extractcs","text":"extractcs(Phys::Vector{PhysicalParamsType{T}}) where T\n\nAssemble the J-coupling and chemical shift values from JSON files for the specified molecules.\n\nConstruction functions for molecule mixture-related configurations in NMRHamiltonian.jl depend on a provided list of the number of spin systems and singlets for each molecule. The constructor functions can be inferred this information from the output quantities of this function.\n\nInputs\n\nPhys::Vector{PhysicalParamsType{T}}\n\nPhysical parameters for multiple molecule entries.\n\nOutputs\n\ncs_sys_mixture:::Vector{Vector{Vector{T}}}\n\nThe set of chemical shift values for non-singlet spin systems for multiple molecule entries. See PhysicalParamsType.\n\ncs_singlets_mixture::Vector{Vector{T}}\n\nSinglet chemical shift values for multiple molecule entries. See PhysicalParamsType.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"simulate","category":"page"},{"location":"api/#NMRHamiltonian.simulate","page":"Public API","title":"NMRHamiltonian.simulate","text":"simulate(\n    Phys::Vector{PhysicalParamsType{T}},\n    molecule_entries::Vector{String},\n    fs::T,\n    SW::T,\n    ν_0ppm::T,\n    config::SHConfig;\n) where T <: AbstractFloat\n\nSimulate the resonance components' intensities and frequencies, compute order of coherences for each component, and group the components into resonance groups.\n\nInputs\n\nPhys – A Vector of physical chemistry parameters, e.g. the output of getphysicalparameters().\nmolecule_entries – A Vector of compound entries.\nfs – the sampling frequency in Hz for use in the simulation.\nSW – the spectral window in ppm for use in the simulation.\nν_0ppm – the 0 ppm peak frequency in Hz in the spectrum, for use in the simulation.\nconfig – a configuration file of type SHConfig.\n\nOutputs\n\nAs::Vector{SHType{Float64}} – the simulated resonance intensities and frequencies, sub-system order of coherences, and resonance groups.\nMSPs – the spin Hamiltonian matrices and coherence-related quantities. For diagnostic purposes.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"readbasechemshifts","category":"page"},{"location":"api/#NMRHamiltonian.readbasechemshifts","page":"Public API","title":"NMRHamiltonian.readbasechemshifts","text":"function readbasechemshifts(P::PhysicalParamsType{T})::Vector{Vector{T}} where T\n\nOutputs shifts, with index structure [spin system][cs index]. cs is in ppm. Singlet spin systems are at the end of shifts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"writebasechemshifts!","category":"page"},{"location":"api/#NMRHamiltonian.writebasechemshifts!","page":"Public API","title":"NMRHamiltonian.writebasechemshifts!","text":"function writebasechemshifts!(P::PhysicalParamsType{T}, shifts::Vector{Vector{T}}) where T\n\nshifts: index structure [spin system][cs index]. cs has to be in ppm. Singlet spin systems are at the end of shifts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"extractMEnuclei","category":"page"},{"location":"api/#NMRHamiltonian.extractMEnuclei","page":"Public API","title":"NMRHamiltonian.extractMEnuclei","text":"extractMEnuclei(     Phys::Vector{PhysicalParamsType{T}}, ) where T\n\nOutputs: IDs, cs, entry_IDs\n\nIDs::Vector{Vector{Int}}\n\nEach entry contains the set of nuclei labels that is associated with the corresponding entry in cs.\n\ncs::Vector{T}\n\nEach entry contains the chemical shift entry of a magnetically equivalent group of nuclei. The magnetic equivalent is based on the data stored in the ME field of the entries in Phy`.\n\nentry_IDs::Vector{Tuple{Int,Int}}\n\nEach entry contains a pair of integers that is associated with the corresponding entry in cs. The first integer is the molecule entry number. The second is the spin system number that the corresponding nuclei in IDs belongs to.\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulation","page":"Public API","title":"Simulation","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"SHConfig","category":"page"},{"location":"api/#NMRHamiltonian.SHConfig","page":"Public API","title":"NMRHamiltonian.SHConfig","text":"@kwdef struct SHConfig{T <: Real}\n    coherence_tol::T = convert(T, 0.01)\n    relative_α_threshold::T = convert(T, 0.005)\n    tol_radius_1D::T = convert(T, 0.1) # \n    nuc_factor::T = convert(T, 1.5)\n    normalize_αs::Bool = true\nend\n\nConfiguration settings for the spin Hamiltonian simulation portion of simulate().\n\nThe parameters here control the trade-off between the number of coherence difference features, the set of Δc's, and the number of resonance groups, the set of Δc_bar's, that are generated. The more resonance groups, the better the approximation to the ideal model where each Δc is a resonance group. The resultant model becomes more computationally intensive as the number of resonance groups increase.\n\n≡≡≡≡≡≡≡≡ Details ≡≡≡≡≡≡≡≡\n\ncoherence_tol::T\n\nThis controls the number of Δc features we get, by how far their sum deviate from -1.\n\nrelative_α_threshold::T\n\nThis controls the number of Δc feature we get, by how intense their corresponding resonance intensity is relative to the maximum intensity within their local spin system.\n\nnormalize_αs::Bool\n\nWhether or not to normalize the resonance intensities according to the number of nuclei in the spin system. It is recommended to leave this to true during normal operation.\n\ntol_radius_1D::T\n\nAn approximate tolerance for merging similar coherence difference features together, when generating resonance groups. Should be strictly between 0 and 1. The lower the number, the more resonance groups are generated.\n\nnuc_factor::T\n\nA guard to prevent too few resoannce groups, unless the coherence difference features, the set of Δc's, are very similar. This should be strictly above 1. The higher this number, the more resonance groups are generated. \n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"SHType","category":"page"},{"location":"api/#NMRHamiltonian.SHType","page":"Public API","title":"NMRHamiltonian.SHType","text":"struct SHType{T}\n\n    # resonance components for each spin systems (indexed by first/outer index).\n    αs::Vector{Vector{T}}\n    Ωs::Vector{Vector{T}}\n\n    Δc::Vector{Vector{Vector{T}}}\n    parts::Vector{Vector{Vector{Int}}}\n    Δc_bar::Vector{Vector{Vector{T}}}\n\n    # the number of spins for each spin system.\n    N_spins_sys::Vector{Int}\n\n    # misc input for the SH simulation.\n    fs::T\n    SW::T\n    ν_0ppm::T\nend\n\nContainer for the spin Hamiltonian simulation result of a molecule entry. All arrays follow the 1-indexing scheme.\n\nFrequency information about the NMR data and spectrometer can be obtained from these information. Spectrometer frequency (in MHz) is calculated as SW/fs, where SW is in ppm, and fs is in Hz. An example value is 700.14 ≈ 14005.6/20.004.\n\nTo convert from Hz to ppm frequency units, and the inverse, use the following anonymous functions:\n\nhz2ppmfunc = uu->(uu - ν_0ppm)*SW/fs\nppm2hzfunc = pp->(ν_0ppm + pp*fs/SW)\n\nFields ≡≡≡≡≡≡≡≡\n\nαs::Vector{Vector{T}}\n\nResonance intensities for each spin systems. Index [i][l] refers to the i-th spin system, l-th resonnace component.\n\nΩs::Vector{Vector{T}}\n\nResonance frequencies for each  spin systems. In units radians. To convert to Hz, divide by 2π.  Index [i][l] refers to the i-th spin system, l-th resonnace component.\n\nΔc::Vector{Vector{Vector{T}}}\n\nIndex [i][l] is a 1-D array of the Δc feature of the l-th resonance component in the i-th spin system. The Δc feature of a resonance component can be interpreted as the partial contributions to the quantum number of the resonance component from each subsystem of the the composite spin system. Its eleemnts take on values betwee -1 and 1 for spin-1/2 NMR.\n\nparts::Vector{Vector{Vector{Int}}}\n\nFor a fixed spin system i, parts[i][k] is a 1-D array of indices that specify which of the resonance components (e.g., which elements of αs[i] and Ωs[i]) belong in the resonance group (i,k). The following creates α_ik, the resonance components for the (i,k)-th resonance group of the molecule entry:\n\nα_ik = αs[parts[i][k]]\n\nThe indices in parts follow the 1-indexing scheme.\n\nΔc_bar::Vector{Vector{Vector{T}}}\n\nIndex [i][k] is the weighted average of the features of the (i,k)-th resonance group. The features are \n\nΔc_ik = Δc[parts[i][k]]\n\nand the weights are \n\nαs[parts[i][k]]\n\nThe length of each Δc_bar[i] in a spin system should be the same, and should be less than or equal to the number of spins in the i-th spin system. It won't be equal if there are exhibits magnetic equivalence between the spins.\n\nN_spins_sys::VectorInt}\n\nThe i-th element is the number of spins in the i-th spin system.\n\nαs_singlets::Vector{T}\n\nThe i-th element is the resonance intensity for the i-th singlet resonance component.\n\nΩs_singlets::Vector{T}\n\nThe i-th element is the resonance frequency for the i-th singlet resonance component. To convert to Hz, divide by 2π.\n\nfsSampling frequency of the spectrometer, in Hz. This is the rate at which the complex-valued free-induction decay signal is sampled at. An example value is around 14005.6 Hz for a 700 MHz spectrometer.\nSWSpectral window in ppm for the spectrometer. An example value is around 20.004 ppm for a 700 MHz spectrometer.\nν_0ppmThe 0 ppm reference frequency, in Hz. An example value is around 10656.01 Hz for a spectrometer with SW ≈ 20.004 ppm and fs ≈ 14005.6 Hz.\n\n\n\n\n\n","category":"type"},{"location":"api/#Serialization,-input/output","page":"Public API","title":"Serialization, input/output","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"serializemixture","category":"page"},{"location":"api/#NMRHamiltonian.serializemixture","page":"Public API","title":"NMRHamiltonian.serializemixture","text":"function serializemixture(\n    As::Vector{SHType{T}},\n) where T\n\nReturns a Dict{Symbol, Any} object, which can then be used with file serialization packages for saving to disk. For use with saveasJSOn(); see its docstring for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"deserializemixture","category":"page"},{"location":"api/#NMRHamiltonian.deserializemixture","page":"Public API","title":"NMRHamiltonian.deserializemixture","text":"deserializemixture(W)\n\nW is of a data type that can be addressed via a key (of type Symbol) and returns a value. Example data types that W can be are Dict{Symbol, Any} or a JSON3 Object.\n\nOutputs a Vector{SHType{T}} variable, where T is the data type of the key :fs in W.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"serializephysicalparams","category":"page"},{"location":"api/#NMRHamiltonian.serializephysicalparams","page":"Public API","title":"NMRHamiltonian.serializephysicalparams","text":"serializephysicalparams(\n    Phys::Vector{PhysicalParamsType{T}},\n    molecule_entries::Vector{String},\n    ) where T\n\nReturns a Dict{Symbol, Any} object, which can then be used with file serialization packages for saving to disk.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"deserializephysicalparams","category":"page"},{"location":"api/#NMRHamiltonian.deserializephysicalparams","page":"Public API","title":"NMRHamiltonian.deserializephysicalparams","text":"deserializephysicalparams(W)\n\nW is of a data type that can be addressed via a key (of type Symbol) and returns a value. Example data types that W can be are Dict{Symbol, Any} or a JSON3 Object.\n\nOutputs a Vector{PhysicalParamsType{T}} and a Vector{String} variable. T is the value stored in the :T key in W.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"saveasJSON","category":"page"},{"location":"api/#NMRHamiltonian.saveasJSON","page":"Public API","title":"NMRHamiltonian.saveasJSON","text":"saveasJSON(     outputfolder::String,     filename::String,     dict, )\n\nExample setup:\n\nconfig = HAM.SHConfig{T}(\n    coherence_tol = convert(T, 0.01),\n    relative_α_threshold = convert(T, 0.005),\n    tol_radius_1D = convert(T, 0.1),\n    nuc_factor = convert(T, 1.5),\n)\nunique_cs_atol = convert(T, 1e-6)\n\nPhys, As, MSPs = HAM.loadandsimulate(\n    T,\n    spectrometer_tag,\n    molecule_entries,\n    H_params_path,\n    molecule_mapping_file_path;\n    config = config,\n    unique_cs_atol = unique_cs_atol\n)\n\nUsage with physical parameters:\n\nS_Phys = HAM.serializephysicalparams(Phys, molecule_entries)\nHAM.saveasJSON(\n    joinpath(save_folder_path, \"Phys.json\"),\n    S_Phys,\n)\n\nUsage with simulation results:\n\nS_As = HAM.serializemixture(As)\nHAM.saveasJSON(\n    joinpath(save_folder_path, \"As.json\"),\n    S_As,\n)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"readJSON","category":"page"},{"location":"api/#NMRHamiltonian.readJSON","page":"Public API","title":"NMRHamiltonian.readJSON","text":"readJSON(file_path::String)\n\nUsage:\n\n# save.\nS_Phys = HAM.serializephysicalparams(Phys, molecule_entries)\nHAM.saveasJSON(\n    Phys_filename,\n    S_Phys,\n)\n\n# load.\ndict_Phys = HAM.readJSON(Phys_filename)\nPhys_rec, molecule_entries_rec = HAM.deserializephysicalparams(Dict(dict_Phys))\n\n\n\n\n\n\n","category":"function"},{"location":"return_vars/#Demo:-return-variables","page":"Demo: return variables","title":"Demo: return variables","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Run the code on the Demo: code walk-through first.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"We'll explore the various field names of the return variables for the simulation. We'll set look at the first compound (i.e., n = 1) and the first spin system (i.e., i = 1) for this demo. In Julia, set these variables:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"n = 1\ni = 1","category":"page"},{"location":"return_vars/#Resonance-components-result-for-the-n-th-compound-entry,-As[n]","page":"Demo: return variables","title":"Resonance components result for the n-th compound entry, As[n]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the As variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(As)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Vector{SHType{Float64}}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable As[n], which corresponds to the 1-st compound entry.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(As[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:αs, :Ωs, :Δc, :parts, :Δc_bar, :N_spins_sys, :fs, :SW, :ν_0ppm)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(As[n], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"9-element Vector{DataType}:\n Vector{Vector{Float64}} # αs\n Vector{Vector{Float64}} # Ωs\n Vector{Vector{Vector{Float64}}} # Δc\n Vector{Vector{Vector{Int64}}} # part\n Vector{Vector{Vector{Float64}}} # Δc_bar\n Vector{Int64} # N_spins_sys\n Float64 # fs, sampling frequency (in Hz) of the spectrometer used for this simulation (i.e., it is an input to the simulation, returned for book keeping).\n Float64 # SW, the spectral window (in ppm) of the spectrometer used for this simulation.\n Float64 # ν_0ppm, the 0 ppm resonance frequency used for this simulation.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Some of the field names are described below:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"αs[i][l]: resonance intensities for the i-th spin system, l-th resonance component. The intensities are relative to the number of nuclei for the n-th compound entry.\nΩs[i][l]: resonance frequencies for the i-th spin system, l-th resonance component. This is a radial frequency, which has units of radians. Divide by 2π to convert to Hz.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"NMRHamiltonian scales αs for a given n-th entry such that we should recover approximately the number of nuclei if we sum over the relative intensities. For example: ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"sum(As[1].αs[1])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"gives","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"4.994790368138611","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This number approaches 5 as relative_α_threshold is set to approach zero, the number of nuclei for the n == 1 compound entry of this demo, which is L-Glutamine. However, setting relative_α_threshold = 0.0 incurs significant computational burden, as every resonance component is kept, even if it has a tiny intensity. In practice, we recommend leaving relative_α_threshold == 0.01 or some other small number, but keep in mind that the sum of the relative intensities would not be exactly equal to the number of nuclei used to assemble the Hamiltonian.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Δc[i][l][j]: order of coherence for the i-th spin system, l-th resonance component, and j-th ME-modulo nuclei index. The set of 1-D arrays Δc[i] is the input set we pass to convex clustering to construct a partition. You can use your own clustering/partition construction algorithm; just overwrite Δc_bar[i] and part[i] accordingly with your results. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"part: a part is an element of a partition in combinatorics literature terminology. part[i][l] contains the resonance component indices (the l index from Δc) that belong in the part for the i-th spin system, j-th part. In NMRHamiltonian, a part of a spin system is called a resonance group, as it is a set of resonance components that share a similar degrees of freedom.\nΔc_bar[i][k][j]: representative order of coherence for the i-th spin system, k-th resonance group, and j-th ME-modulo nuclei index. The number of k index values is the number of parts that convex clustering returned.\nN_spins_sys[i]: the number of nuclei in the i-th spin system. These are not ME_modulo nuclei. This is used for normalization purposes for finalizing αs.","category":"page"},{"location":"return_vars/#Spin-system-information-for-the-n-th-compound-entry,-MSPs[n]","page":"Demo: return variables","title":"Spin system information for the n-th compound entry, MSPs[n]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the MSPs variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(MSPs)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Vector{MoleculeSpinSystem{Float64}}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable Rs[n][i], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(MSPs[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:spin_systems, :singlet_intensities, :singlet_frequencies)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"spin_systems: Discussed shortly.\nsinglet_intensities[m]: The m-th singlet intensity of the n-th compound entry.\nsinglet_frequencies[m]: The m-th singlet (radial) frequency (in radians) of the n-th compound entry.","category":"page"},{"location":"return_vars/#Hamiltonian-for-the-n-th-compound-entry,-i-th-spin-system,-MSPs[n].spin_system[i]","page":"Demo: return variables","title":"Hamiltonian for the n-th compound entry, i-th spin system, MSPs[n].spin_system[i]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the MSPs[n].spin_systems[i] variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(MSPs[n].spin_systems[i])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"NMRHamiltonian.SpinSystem{Float64}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable MSPs[n].spin_systems[i], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(MSPs[n].spin_systems[i])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:intensities, :frequencies, :H, :coherence_mat, :coherence_state_pairs, :states, :partial_quantum_numbers, :quantum_numbers, :coherence_tol)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(MSPs[n].spin_systems[i], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"9-element Vector{DataType}:\n Vector{Float64} (alias for Array{Float64, 1}) # intensities\n Vector{Float64} (alias for Array{Float64, 1}) # frequencies\n NMRHamiltonian.Hamiltonian{Float64} # H\n Matrix{Float64} (alias for Array{Float64, 2}) # coherence_mat\n Vector{Tuple{Int64, Int64}} (alias for Array{Tuple{Int64, Int64}, 1}) # coherence_state_pairs\n Vector{Int64} (alias for Array{Int64, 1}) # states\n Vector{Vector{Float64}} (alias for Array{Array{Float64, 1}, 1}) # partial_quantum_numbers\n Vector{Float64} (alias for Array{Float64, 1}) # quantum_numbers\n Float64 # coherence_tol","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"intensities: These are all the resonance intensities that passed the (-1)-quantum coherence condition (within a numerical tolerance of coherence_tol). The αs intensities were created from intensities.\nfrequencies: Similar to intensities, but for resonance (radial) frequencies, in radians.\nH: information for the Hamiltonian matrix. The H.matrix is the Hamiltonian matrix. H.contributions is a 1-D array of two matrices that sum to H.matrix, each of the matrices corresponds to a term in the Hamiltonian equation in our manuscript. The H.eigenvalues and H.eigenvectors are the eigenpairs of H.matrix.\ncoherence_mat: this is the order of coherence as computed using the z-axis spin angular momentum.\ncoherence_state_pairs: this is the eigenstate pairs (sometimes denoted by {(r,s)} in our manuscript) that corresponds to each resonance component in intensities and frequencies.\nstates: the unique states in coherence_state_pairs.\npartial_quantum_numbers: the contributions to the quantum number of each state in states. One contribution from each quantum sub-system, where each sub-system is a ME-modulo nuclei index. These generate the order of coherence features Δc.\nquantum_numbers: the quantum numbers of an eigenstate, used to determine if a state-pair from coherence_state_pairs satisfies the (-1)-quantum coherence condition (within a numerical tolerance of coherence_tol). If it does, the state-pair creates a valid resonance component, and its intensity and frequency is computed and stored as an element of intensities and frequencies, respectively.","category":"page"},{"location":"return_vars/#Physical-chemistry-parameters-for-the-n-th-compound-entry,-Phys[n]","page":"Demo: return variables","title":"Physical chemistry parameters for the n-th compound entry, Phys[n]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the Phys[n] variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(Phys[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"NMRHamiltonian.PhysicalParamsType{Float64}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable Phys[n], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(Phys[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:H_IDs, :H_inds_sys, :cs_sys, :H_inds_singlets, :cs_singlets, :J_inds_sys, :J_inds_sys_local, :J_vals_sys, :ME)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(Phys[n], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"9-element Vector{DataType}:\n Vector{Int64} # H_IDs\n Vector{Vector{Int64}} # H_inds_sys\n Vector{Vector{Float64}} # cs_sys\n Vector{Vector{Int64}} # H_inds_singlets\n Vector{Float64} # cs_singlets\n Vector{Vector{Tuple{Int64, Int64}}} # J_inds_sys\n Vector{Vector{Tuple{Int64, Int64}}} # J_inds_sys_local\n Vector{Vector{Float64}} # J_vals_sys\n Vector{Vector{Vector{Int64}}} # ME","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"H_IDs: The nuclei labels parsed from the physical chemistry file for the n-th compound entry.\nH_inds_sys[i]: The nuclei from a re-labelled H_IDs that are in the i-th spin system. The re-label starts from 1, and increments by 1.\ncs_sys[i]: The chemical shifts (in units ppm) that corresponds to the nuclei in H_inds_sys[i], for the i-th spin system.\nH_inds_singlets: The nuclei from a re-labelled H_IDs that generate singlet spin systems.\ncs_singlets: The chemical shifts (in units ppm) that corresponds to the nuclei in H_inds_singlets.\nJ_inds_sys[i]: Pairs of nuclei from H_inds_sys[i] such that each pair has a J-coupling value for the i-th spin system.\nJ_inds_sys_local[i]: This is a version of J_inds_sys[i] but the nuclei indices are re-labelled to start from 1, i.e. this is a re-labelling of the nuclei for the i-th spin system.\nJ_vals_sys: J-coupling values in Hz, corresponds to the nuclei in J_inds_sys[i] and J_inds_sys_local[i].\nME[i][m]: The nuclei indices from a re-labelled H_IDs (so that it starts from 1, increments by 1) for the m-th non-singleton ME-modulo nuclei index in the i-th spin system. This means ME[i][m] contains some nuclei labels that together form the m-th set of nuclei such that it contains only nuclei that are magnetically equivalent to each other, and this m-th set of nuclei is the largest possible set. Non-singleton means that ME[i][m] does not include nucleus that are not magnetically equivalent to anyone else; any nucleus is magnetically equivalent to itself, and we exclude it to be in ME[i][m]. For example, if Phys[n].ME[i] contains ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"2-element Vector{Vector{Int64}}:\n [7, 5, 6] # assign to j == 1\n [1, 2, 3] # assign to j == 2.\n # The other values of j's are assigned according to ascending numerical value of whatever nuclei labels are left in this spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"then it means the n-th compound entry, i-th spin system has two non-singleton magnetically equivalent set of nuclei. The first set of nuclei is nuclei {7,5,6} and the second set is nuclei {1,2,3}. If there are 8 nuclei for this compound entry, then nuclei 4 and 8 are both not magnetically equivalent to any other nuclei that isn't itself. The ME-module index j for this spin system would be {1,2,3,4}, with j == 1 representing nuclei {7,5,6}, j == 2 representing nuclei {1,2,3}, j == 3 representing nucleus 4, j == 4 representing nucleus 8.","category":"page"},{"location":"return_vars/#Store-simulated-variables","page":"Demo: return variables","title":"Store simulated variables","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"JSON: in this demo, we use the JSON3.jl library for loading JSON. Please make sure it is installed before running the following code.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"# store.\nfile_name = \"test.json\"\nS = NMRHamiltonian.serializemixture(As)\nNMRHamiltonian.saveasJSON(file_name, S)\n\n# load.\nimport JSON 3\nfile_path = file_name\njson_string = read(file_path)\nW = JSON3.read(json_string)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"You can also use BSON.jl.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"# store.\nfile_name = \"test.bson\"\nS = NMRHamiltonian.serializemixture(As)\nBSON.bson(file_name, S)\n\n# load.\nW = BSON.load(file_name)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"A round-trip test routine is in the test folder of the NMRHamiltonian repository. See the functions roundtripJSON() and roundtripBSON() in that folder for more details on the test.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"An alternative method to serialize data is with the Julia Base Serialization library. My understanding is that compatibility is not guaranteed between Julia versions, so it should be used for short-term storage.","category":"page"},{"location":"demo_code/#Demo:-code-walk-through","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"","category":"section"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"For those who prefer working with source files instead of the Julia REPL and notebooks, this demo follows the script examples/simulate.jl, which is derived from examples/simulate_SH.jl in the NMRHamiltonian repository. In this demo, we load the physical chemistry parameters and alias mapping files, then simulate the resonance frequency and intensity, followed by an application of the convex clustering to partition the resonance components into resonance groups.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"First, load the libraries. You can use using (loads NMRHamiltonian into current namespace) or import (loads NMRHamiltonian into its own namespace NMRHamiltonian). We use the latter in this demo.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"The code involving DataDeps, Tar, CodecZlib were developed on DataDeps v0.7.11, Tar v1.10.0, CodecZlib v0.7.3. You might need to modify it if you use a different version of DataDeps.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"import NMRHamiltonian\nHAM = NMRHamiltonian # so we don't need to type NMRHamiltonian. everytime we reference something from this library.\n\n\nusing DataDeps, Tar, CodecZlib\n\nusing LinearAlgebra\nimport PythonPlot # do Pkg.add(\"PythonPlot\") if you're missing this library.\n\n# the same function for ensuring the dataset at 10.5281/zenodo.8174261 is downloaded.\n\nfunction getdatapath()::String\n\n    dataset_alias = \"AI4DBiological-Systems_NMR_data\" # don't use spaces or 'strange' symbols like commas, colons, etc.\n    archive_file_name = \"nmr_physical_parameters_dataset.tar.gz\" # the filename on the data repository that we download.\n    url = \"https://zenodo.org/record/8174261/files/nmr_physical_parameters_dataset.tar.gz?download=1\"\n\n    register(DataDep(\"$dataset_alias\",\n        \"\"\"\n        Dataset: Selected BMRB 1D 1H NMR data and physical chemistry values compiled from literature\n        Author: Roy Chih Chung Wang\n        License: [Creative Commons Attribution Non Commercial Share Alike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode)\n        DOI: 10.5281/zenodo.8174261\n\n        Description:\n        The experiments were downloaded from BMRB,\n        The physical chemistry parameters data and sample configuration-related files were collected, organized, converted or manually entered in as JSON files by Roy.\n        The physical chemistry parameters, i.e., chemical shift and J-coupling values, are from two sources:\n        - GISSMO: (https://gissmo.bmrb.io/ acccessed Mar. 2023). See Dashti, et. al. DOI: 10.1021/acs.analchem.8b02660 and DOI: 10.1021/acs.analchem.7b02884 for more details.\n        - From Govindaraju, et. al.'s work: DOI: 10.1002/1099-1492(200005)13:3<129::AID-NBM619>3.0.CO;2-V\n\n        Please cite the data sources and this data repository if you find the contents helpful for your work. See the Zenodo DOI entry for more description.\n        \"\"\",\n        url\n    ));\n\n    #readdir(datadep\"AI4DBiological-Systems NMR data\") # have to manually type out the alias. Does not allow string variable substitution.\n    local_dataset_archive_path = @datadep_str(\"$dataset_alias\") # call the actual macro to allow string variable substitution.\n\n    # extract archive, then delete. Do this only if archive file still exists.\n\n    root_data_path = joinpath(local_dataset_archive_path, \"contents\")\n    \n    if isfile(joinpath(local_dataset_archive_path, archive_file_name))\n        t = @task begin; ispath(root_data_path) || mkpath(root_data_path); end\n        schedule(t); wait(t)\n    \n        #t = @task begin; Tar.extract(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        t = @task begin; extractuncompress(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        schedule(t); wait(t)\n        rm(joinpath(local_dataset_archive_path, archive_file_name)) # delete the archive file.\n    end\n\n    return root_data_path\nend\n\nfunction extractuncompress(src_path, dest_path)\n    tar_gz = open(src_path)\n    tar = GzipDecompressorStream(tar_gz)\n    dir = Tar.extract(tar, dest_path)\n    close(tar)\n    \n    return dir\nend\n\n# This was tested in a REPL environment, not a notebook environment. You might need to modify this for notebooks to get it to display the plots.\nPythonPlot.close(\"all\")\nfig_num = 1\n\n# select the AbstractFloat data type you want to use. Anything lower than Float32 will result in numerical precision-related errors in our tests.\n#T = Float64\nT = Float32","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"The variable molecule_entries contain compound aliases. For this demo, any alias in the molecule_name_mapping/select_molecules.json file from 10.5281/zenodo.8174261 would work.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"### user inputs.\n\nmolecule_entries = [\n    \"L-Serine\";\n    \"alpha-D-Glucose\";\n    \"beta-D-Glucose\";\n    \"Ethanol\";\n    \"L-Methionine\";     \n    \"L-Phenylalanine\";\n    \"L-Glutathione reduced\";\n    \"L-Glutathione oxidized\";       \n    \"Uridine\";\n    \"L-Glutamine\";\n    \"L-Valine\";\n    \"DSS\";\n]\n\n# machine values taken from the BMRB 700 MHz 20 mM glucose experiment.\nfs, SW, ν_0ppm = HAM.getpresetspectrometer(T, \"700\")\n\n## pull the sample coupling values into dictionary structures.\n# use DataDeps.jl and Tar.jl to download and extract the sample coupling values.\nroot_data_path = getdatapath() # coupling values data repository root path\n\nH_params_path = joinpath(root_data_path, \"coupling_info\") # folder of coupling values. # replace with your own values in actual usage.\n\n\nmolecule_mapping_root_path = joinpath(\n    root_data_path,\n    \"molecule_name_mapping\",\n)\nmolecule_mapping_file_path = joinpath(\n    molecule_mapping_root_path,\n    \"select_molecules.json\",\n)\n#molecule_mapping_file_path = joinpath(molecule_mapping_root_path, \"GISSMO_names.json\")\n\n\n# Type ?help HAM.SHConfig for details.\nconfig_SH = HAM.SHConfig{T}(\n    coherence_tol = convert(T, 0.01),\n    relative_α_threshold = convert(T, 0.005),\n    tol_radius_1D = convert(T, 0.1), # strictly between 0 and 1. The lower, the better the approximation, but would a larger partition (i.e. more resonance groups).\n    nuc_factor = convert(T, 1.5),\n)\n","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"Now, load the parameters, simulate the resonance components, and partition into resonance groups.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"# read the physical parameters from file, from via the DataDeps routine from \"helpers/data.jl\".\nPhys = NMRHamiltonian.getphysicalparameters(\n    T,\n    molecule_entries,\n    H_params_path,\n    molecule_mapping_file_path;\n    unique_cs_atol = convert(T, 1e-6),\n)\n# You can tweak the J-coupling or chemical shift values of Phys manually if desired, before calling simulate(). We won't tweak anything in this demo.\n\n# Assemble and eigendecompose the Hamiltonian, get frequencies and intensities for each resonance component, and partition the comonents into resonance groups.\nAs, MSPs = HAM.simulate(\n    Phys,\n    molecule_entries,\n    fs,\n    SW,\n    ν_0ppm,\n    config_SH,\n)","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"Now, we'll plot the absorption Lorentzian spectrum of the simulated resonance frequencies and intensities. We'll have to make up a T2 relaxation value, which corresponds to the component width.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"We will focus in on the first molecule (change molecule_select = 1 to select a different molecule, the molecule names are in molecule_entries) and its first spin system (change spin_system_select = 1 to select a different spin system). If T was set to a floating-point data type other than the default one from your operating system's architecture, then you need to explicitly type-cast each floating-point number to type T, via convert. To find out what the default floating-point data type is, run typeof(1.0).","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"### visualize a target molecule and spin group, given a T-2 decay parameter.\nλ0 = convert(T, 3.4) # make up a T-2 decay parameter for this plotting example.\nmolecule_select = 1\nspin_system_select = 1\nppm_offset = convert(T, 0.2) # for display padding.\nN_viz = 50000 # this many points to plot\n\ntwo_pi_T = convert(T, 2*π)\n\nprintln(\"Visualizing $(molecule_entries[molecule_select]) and spin system $(spin_system_select).\")\n\na = As[molecule_select].αs[spin_system_select]\nF = As[molecule_select].Ωs[spin_system_select]\n\nhz2ppmfunc = uu->(uu - ν_0ppm)*SW/fs # Hz to ppm conversion. This is useful to remember.\nppm2hzfunc = pp->(ν_0ppm + pp*fs/SW) # ppm to Hz conversion. This is useful to remember.\n\nΩS_ppm = hz2ppmfunc.( F ./ two_pi_T ) # convert to radial frequency.\nΩS_ppm_sorted = sort(ΩS_ppm)\n\nu_min = ppm2hzfunc(ΩS_ppm_sorted[1] - ppm_offset)\nu_max = ppm2hzfunc(ΩS_ppm_sorted[end] + ppm_offset)\n\nP_min = hz2ppmfunc(u_min)\nP_max = hz2ppmfunc(u_max)\n\nP = LinRange(P_min, P_max, N_viz)\nU = ppm2hzfunc.(P)\nU_rad = U .* two_pi_T\n\n# absorption Lorentzian.\nfunction evalzerophasecl1Darray(u_rad, αs::Vector{T}, Ωs::Vector{T}, λ::T)::Complex{T} where T <: AbstractFloat\n\n    out = zero(Complex{T})\n    for l = 1:length(αs)\n        out += evalzerophaseclpartitionelement(u_rad, αs[l], Ωs[l], λ)\n    end\n\n    return out\nend\n\nfunction evalzerophaseclpartitionelement(r,\n    α::T, Ω::T, λ::T)::Complex{T} where T <: AbstractFloat\n\n    out = α/(λ+im*(r-Ω))\n\n    return out\nend\n\nq = uu->evalzerophasecl1Darray(uu, a, F, λ0)\nq_U = q.(U_rad)\n\n# plot.\nPythonPlot.figure(fig_num)\nfig_num += 1\n\nPythonPlot.plot(P, real.(q_U))\n\nPythonPlot.gca().invert_xaxis()\nPythonPlot.ylabel(\"real part\")\nPythonPlot.title(\"spectrum of $(molecule_entries[molecule_select]), spin system $(spin_system_select)\")","category":"page"},{"location":"#NMRHamiltonian.jl","page":"Overview","title":"NMRHamiltonian.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"NMRHamiltonian is a library for simulating the resonance frequencies and relative intensities of compounds in isotropic liquid. It is intended for 1D 1H NMR, which is a spin-1/2 NMR. ","category":"page"},{"location":"#Table-of-contents","page":"Overview","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Install","page":"Overview","title":"Install","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"NMRHamiltonian is hosted on a custom Julia registry. We need to add that before installing NMRHamiltonian: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/AI4DBiological-Systems/PublicJuliaRegistry\"))\nPkg.add(\"NMRHamiltonian\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To update this package once it is installed, do","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.update(\"NMRHamiltonian\")","category":"page"},{"location":"#Important-exported-functions","page":"Overview","title":"Important exported functions","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The following functions are the focus of NMRHamiltonian:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"getphysicalparameters() given a list of compound aliases, parse the physical chemistry parameters from file to data structure.\nSHConfig() assembles the simulation configuration container variable. This is a constructor to a composite data type (i.e., this data type is like the C programming language's struct).\nsimulate() the outputs of getphysicalparameters() and SHConfig(), and returns a data structure that contain the simulated frequencies and relative intensities for each resonance comonents, and their resonance groups.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is not a full quantum simulation of the NMR spectrum; only the frequencies, intensities, and this partition of the resonance components called a set of resonance groups is returned.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"See the demo pages for an example walk-through of how to use this library.","category":"page"},{"location":"#Julia-Basics","page":"Overview","title":"Julia Basics","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Read the Julia documentation for installing Julia packages.\nWe use 1-indexing for addressing arrays here, but you can use [begin + n] instead of [n] if you wish to use a 0-indexing index n. ","category":"page"},{"location":"#A-compiled-list-of-physical-chemistry-parameters","page":"Overview","title":"A compiled list of physical chemistry parameters","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The getphysicalparameters() function in NMRHamiltonian requires the user to supply it with a list of compound aliases, each of which is a string called an entry, as well as the corresponding file path of each entry to a JSON file that stores its physical chemistry parameters. These parameters are the chemical shift and J-coupling values of an compound, as we are only concerned with spin-1/2 NMR in isotropic liquid in NMRHamiltonian. As some of these values change as a function of ambient temperature, pH, spectrometer frequency, one can have multiple entries that describe the same compound for different experimental or spectrometer configurations.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The demo and test scripts for NMRHamiltonian.jl requires the compiled list of parameters at 10.5281/zenodo.8174261, but you are encouraged to devise your own that follows its JSON format. You'll need a alias-to-file-path mapping file, which is the molecule_name_mapping/selected_molecules.json file from this dataset. You'll also need the individual parameter files for each compound at a certain experimental or spectrometer configurations, which are the files in the coupling_info folder from this dataset. See these files to get a sense of how the format is like.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For the parameter files, the JSON file structure goes like this:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"{\n       \"J-coupling\": [\n                       {\n                            \"ID2\": 9,\n                            \"ID1\": 8,\n                          \"value\": -12.531894\n                       },\n                       {\n                            \"ID2\": 10,\n                            \"ID1\": 8,\n                          \"value\": 3.511369\n                       },\n                       {\n                            \"ID2\": 10,\n                            \"ID1\": 9,\n                          \"value\": 5.979\n                       }\n                     ],\n   \"chemical shift\": [\n                       {\n                          \"value\": 3.9744,\n                             \"ID\": 8\n                       },\n                       {\n                          \"value\": 3.9352,\n                             \"ID\": 9\n                       },\n                       {\n                          \"value\": 3.83016,\n                             \"ID\": 10\n                       }\n                     ]\n}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is the L-Serine_mod.json file in coupling_info from the dataset. This indicates that there are J-couplings (nucleus 1 ID, nucleus 2 ID, J-coupling value in Hz) = (8, 9, -12.531894), (8, 10, 3.511369), (9, 10, 5.979). There are chemical shifts for each nuclei: (8, 3.9744 ppm), (9, 3.9352 ppm), (10, 3.83016 ppm).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can construct ficticious compound entries and simulate it, just to see what the resonance frequencies and intensities might look like.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For the mapping file, it follows the format:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"{\n    \"Dopamine - 500 MHz\": {\n        \"notes\": \"http://gissmo.bmrb.io/entry/bmse000909/simulation_1\",\n        \"file name\": \"bmse000909_simulation_1.json\"\n    },\n    \"L-Cystine\": {\n        \"notes\": \"http://gissmo.bmrb.io/entry/bmse000035/simulation_1\",\n        \"file name\": \"bmse000035_simulation_1.json\"\n    },\n}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It means that the parameter file for compound alias \"Dopamine - 500 MHz\" is bmse000909_simulation_1.json in the nuclei parameter file path folder, which together with the file path for the mapping file, are inputs to the getphysicalparameters() function in this library. We will go over this function in the demo.","category":"page"},{"location":"#Citation","page":"Overview","title":"Citation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Please cite 10.5281/zenodo.8174261 and the appropriate references within if you use any physical chemistry values from it. The references to the original data sources from which these values were curated from are also in the instructions.","category":"page"},{"location":"#Download-a-NMR-parameters-dataset-via-DataDeps.jl","page":"Overview","title":"Download a NMR parameters dataset via DataDeps.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Run the following commands to load the getdatapath() function into Julia REPL, which calls DataDeps.jl to download and uses Tar.jl and CodecZlib to extract the files on your local machine. If you usually use a source file workflow, these commands are stored in examples/helpers/data.jl in the NMRHamiltonian repository.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using DataDeps, Tar, CodecZlib\n\n\nfunction getdatapath()::String\n\n    dataset_alias = \"AI4DBiological-Systems_NMR_data\" # don't use spaces or 'strange' symbols like commas, colons, etc.\n    archive_file_name = \"nmr_physical_parameters_dataset.tar.gz\" # the filename on the data repository that we download.\n    url = \"https://zenodo.org/record/8174261/files/nmr_physical_parameters_dataset.tar.gz?download=1\"\n\n    register(DataDep(\"$dataset_alias\",\n        \"\"\"\n        Dataset: Selected BMRB 1D 1H NMR data and physical chemistry values compiled from literature\n        Author: Roy Chih Chung Wang\n        License: [Creative Commons Attribution Non Commercial Share Alike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode)\n        DOI: 10.5281/zenodo.8174261\n\n        Description:\n        The experiments were downloaded from BMRB,\n        The physical chemistry parameters data and sample configuration-related files were collected, organized, converted or manually entered in as JSON files by Roy.\n        The physical chemistry parameters, i.e., chemical shift and J-coupling values, are from two sources:\n        - GISSMO: (https://gissmo.bmrb.io/ acccessed Mar. 2023). See Dashti, et. al. DOI: 10.1021/acs.analchem.8b02660 and DOI: 10.1021/acs.analchem.7b02884 for more details.\n        - From Govindaraju, et. al.'s work: DOI: 10.1002/1099-1492(200005)13:3<129::AID-NBM619>3.0.CO;2-V\n\n        Please cite the data sources and this data repository if you find the contents helpful for your work. See the Zenodo DOI entry for more description.\n        \"\"\",\n        url\n    ));\n\n    #readdir(datadep\"AI4DBiological-Systems NMR data\") # have to manually type out the alias. Does not allow string variable substitution.\n    local_dataset_archive_path = @datadep_str(\"$dataset_alias\") # call the actual macro to allow string variable substitution.\n\n    # extract archive, then delete. Do this only if archive file still exists.\n\n    root_data_path = joinpath(local_dataset_archive_path, \"contents\")\n    \n    if isfile(joinpath(local_dataset_archive_path, archive_file_name))\n        t = @task begin; ispath(root_data_path) || mkpath(root_data_path); end\n        schedule(t); wait(t)\n    \n        #t = @task begin; Tar.extract(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        t = @task begin; extractuncompress(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        schedule(t); wait(t)\n        rm(joinpath(local_dataset_archive_path, archive_file_name)) # delete the archive file.\n    end\n\n    return root_data_path\n\n    # # return root_data_path. however, this unpacks in the current working directory!\n    # archive_file_path = joinpath(local_dataset_archive_path, archive_file_name)\n    # if isfile(archive_file_path)\n    #     DataDeps.unpack(archive_file_path)\n    # end\n    #return local_dataset_archive_path\nend\n\nfunction extractuncompress(src_path, dest_path)\n    tar_gz = open(src_path)\n    tar = GzipDecompressorStream(tar_gz)\n    dir = Tar.extract(tar, dest_path)\n    close(tar)\n    \n    return dir\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Now, run this function to download and extract the data.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"getdatapath()","category":"page"},{"location":"#Terminology","page":"Overview","title":"Terminology","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A ME-modulo nuclei index corresponds to a maximal set of nuclei where each nucleus is magnetically equivalent (ME) with all other nucleus in that maximal set. For example: if compound X has 10 nuclei contributing to its 1D 1H NMR spectrum, but nucleus #2 and #5 are ME, the other nucleus do not form ME with each other, then we can re-label the nuclei indices i = 1, 2, ..., 10 to the ME-modulo nuclei index j = 1, 2, ..., 9, with j = 2 denoting the set of nuclei {i == 2, i == 5}. The order of coherences-related quantities in NMRHamiltonian use ME-modulo nuclei indices as oppose to the nuclei indices.\nA radial frequency in units of radians is a frequency in Hz multiplied by 2π.\nA resonance group is a set of resonance components that have similar degrees-of-freedom. The set of resonance groups of a spin system is a partition of the resonance components for that spin system.\nA part is an element of a partition of a set X. This means a part is a subset of X.\nThroughout this documentation, we use x == y to mean the value in variable x equals to the value in variable y. We use x = y to mean we assign the variable x the value  y.","category":"page"},{"location":"#License","page":"Overview","title":"License","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"NMRHamiltonian has the Mozilla Public License Version 2.0.","category":"page"},{"location":"#Authors","page":"Overview","title":"Authors","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Code author:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Roy Chih Chung Wang","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Supervisors:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Dave Campbell (Carleton University, Bank of Canada)\nMiroslava Čuperlović-Culf (National Research Council of Canada)","category":"page"},{"location":"#Funding","page":"Overview","title":"Funding","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This projected was funded by the AI-for-Design Challenge Program from the National Research Council of Canada.","category":"page"}]
}
