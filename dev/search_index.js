var documenterSearchIndex = {"docs":
[{"location":"api/#Function-References","page":"Public API","title":"Function References","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"getphysicalparameters","category":"page"},{"location":"api/#NMRHamiltonian.getphysicalparameters","page":"Public API","title":"NMRHamiltonian.getphysicalparameters","text":"getphysicalparameters(\n    ::Type{T},\n    target_entries::Vector{String},\n    H_params_path::String,\n    molecule_mapping_file_path;\n    unique_cs_atol = 1e-6,\n) where T <: AbstractFloat\n\nAssemble the J-coupling and chemical shift values from JSON files for the specified molecules.\n\nNomenclature\n\nOne set of J-coupling and one set of chemical shift values for a molecule is what NMRHamiltonian.jl calls a molecule entry.\n\nIt is common to see different J-coupling values of the same molecule reported in literature for similar experimental conditions.  NMRHamiltonian.jl requires one to record each instance as separate molecule entry.\n\nEvery molecule entry is recorded as a separate JSON file with some arbitrary file name the data collector wants to use. An additional name-mapping JSON file is needed to translate what the NMRHamiltonian.jl user wants to label the entries to what is the data collector chose to name the JSON files. The name-mapping JSON file is likely to require manual set up.\n\nInputs\n\n::Type{T}       – The AbstractFloat datatype to use for storing floating point data. A viable input here is Float64, which specifies double precision floating point numbers are to be used.\ntarget_entries  – list of molecule entry names.\nH_params_path   – path to the directory that contain the J-coupling and chemical shift JSON files. Each file corresponds to one entry of a molecule, and has a set of chemical shifts and J-coupling information in the JSON dictionary format.   ID1 and ID2 are JSON dictionary keys that specify the spin nucleus label for J-coupling values, and ID is the nucleus label for chemical shift values. The following is an example of the JSON format for a L-Histidine entry:\n\n{\n       \"J-coupling\": [\n                       {\n                            \"ID2\": 13,\n                            \"ID1\": 12,\n                          \"value\": -15.350518\n                       },\n                       {\n                            \"ID2\": 16,\n                            \"ID1\": 12,\n                          \"value\": 7.63377\n                       },\n                       {\n                            \"ID2\": 16,\n                            \"ID1\": 13,\n                          \"value\": 5.029267\n                       }\n                     ],\n   \"chemical shift\": [\n                       {\n                          \"value\": 3.18747,\n                             \"ID\": 12\n                       },\n                       {\n                          \"value\": 3.26837,\n                             \"ID\": 13\n                       },\n                       {\n                          \"value\": 7.14078,\n                             \"ID\": 14\n                       },\n                       {\n                          \"value\": 8.02487,\n                             \"ID\": 15\n                       },\n                       {\n                          \"value\": 3.9967,\n                             \"ID\": 16\n                       }\n                     ]\n}\n\nmolecule_mapping_file_path   – the files in H_params_path might not be named in a manner for the user to know which molecule entry corresponds to which JSON file. Therefore, the user should further define a single JSON file that encodes this mapping.   Example: if the file bmse000976_simulation_1.json corresponds to the molecule entry \"L-Histidine\" and the file Histidine_Govindaraju_2000.json corresponds to the molecule entry \"L-Histidine - Govindaraju\", and suppose the user only wants to target these two entries, i.e. target_entries contain only these two entries. Then the following entry-filename-mapping JSON file should be used, and molecule_mapping_file_path should be the path to this entry-filename-mapping file.\n\n{\n    \"L-Histidine\": {\n        \"notes\": \"http://gissmo.bmrb.io/entry/bmse000976/simulation_1\",\n       \"file name\": \"bmse000976_simulation_1.json\"\n    },\n    \"L-Histidine - Govindaraju\": {\n        \"notes\": \"https://pubmed.ncbi.nlm.nih.gov/10861994/\",\n       \"file name\": \"Histidine_Govindaraju_2000.json\"\n    }\n}\n\nOptional inputs\n\nunique_cs_atol   – Two chemical shift values in the same JSON file are assigned the same chemical shift value to both nuclei if the two values in the file are less than unique_cs_atol.\n\nOutputs\n\nPhys::Vector{PhysicalParamsType{Float64}    – list of the data type PhysicalParamsType that contain chemical shift and J-coupling information for each of the molecule entries in target_entries.\ndict_molecule_to_filename                   – the dictionary that maps molecule entries to meta information such as their corresponding JSON filenames\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"SHConfig","category":"page"},{"location":"api/#NMRHamiltonian.SHConfig","page":"Public API","title":"NMRHamiltonian.SHConfig","text":"function SHConfig(     ::Type{T};     coherencetol = 0.01,     relativeαthreshold = 0.01,     maxpartitionsizeoffset::Integer = 0,     partitionrate::Real = 2.0,     #searchθ::Bool = true,     #searchγ::Bool = true,     #θdefault = 0.0,     γbase = 0.1,     γrate = 1.05,     maxiterγ = 100,     fullyconnectedconvexclustering = false, #  overides all knn-related optional inputs     maxconnectedcomponentsoffset = -1,     startingmanualknn = 60,     lengthscalebase = 10.0,     lengthscalerate = 0.7,     mindynamicrange = 0.95,     ccgaptol = 1e-8,     ccmaxiters = 300,     assignmentzerotol = 1e-3,     reportγcost::Bool = true,     verbose_kernel::Bool = true,     )::SHConfig{T} where T\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"Public API","title":"Public API","text":"simulate","category":"page"},{"location":"api/#NMRHamiltonian.simulate","page":"Public API","title":"NMRHamiltonian.simulate","text":"simulate(\n    part_algs::Vector{Vector{PartitionAlgorithmType}},\n    names::Vector{String},\n    fs::T,\n    SW::T,\n    ν_0ppm::T,\n    Phys::Vector{PhysicalParamsType{T}},\n    configs::Vector{SHsConfigType{T}}\n    ) where T <: AbstractFloat\n\nPerforms spin hamiltonian simulation and resonance group partitioning of the molecule entries in names.\n\nInputs\n\npart_algs::Vector{Vector{PartitionAlgorithmType}}\n\nElement [n][i] is the partition algorithm config molecule entry n, non-singlet spin system i.\n\nnames::Vector{String}\n\nList of molecule entries.\n\nfsSampling frequency of the spectrometer, in Hz. This is the rate at which the complex-valued free-induction decay signal is sampled at. An example value is around 14005.6 Hz for a 700 MHz spectrometer.\n\nSWSpectral window in ppm for the spectrometer. An example value is around 20.004 ppm for a 700 MHz spectrometer.\n\nν_0ppmThe 0 ppm reference frequency, in Hz. An example value is around 10656.01 Hz for a spectrometer with SW ≈ 20.004 ppm and fs ≈ 14005.6 Hz.\n\nPhys::Vector{PhysicalParamsType{T}}\n\nList of chemical shift and J-coupling information for each molecule entry.\n\nconfigs::Vector{SHsConfigType{T}}\n\nList of spin Hamiltonian simulation configurations for each molecule entry.\n\nOutputs\n\nAs::SHType{T}\n\nA list of spin Hamiltonian result data structure variables. \n\nRs::Vector{Vector{PartitionSearchRecord}}\n\nA list of iterative search results for the partitioning algorithm. This variable is only useful if an iterative search was done for regulariation parameter γ or/and kernel hyperparameter θ.\n\n\n\n\n\nsimulate(\n    Phys::Vector{PhysicalParamsType{T}},\n    molecule_entries::Vector{String},\n    fs::T,\n    SW::T,\n    ν_0ppm::T,\n    config::SHConfig;\n\n    θs::Vector{Vector{T}} = defaultspinsysbuffer(convert(T,Inf), Phys), # non-finite value means use search strategy.\n    γs::Vector{Vector{T}} = defaultspinsysbuffer(convert(T,Inf), Phys),\n\n    γ_bases = defaultspinsysbuffer(config.γ_base, Phys),\n    γ_rates = defaultspinsysbuffer(config.γ_rate, Phys),\n    γ_max_iters = defaultspinsysbuffer(config.max_iter_γ, Phys),\n\n    length_scale_bases = defaultspinsysbuffer(config.length_scale_base, Phys),\n    length_scale_rates = defaultspinsysbuffer(config.length_scale_rate, Phys),\n    min_dynamic_ranges = defaultspinsysbuffer(config.min_dynamic_range, Phys),\n) where T <: AbstractFloat\n\nSimulate the resonance components' intensities and frequencies, compute order of coherences for each component, and group the components into resonance groups.\n\nInputs\n\nPhys – A Vector of physical chemistry parameters, e.g. the output of getphysicalparameters().\nmolecule_entries – A Vector of compound entries.\nfs – the sampling frequency in Hz for use in the simulation.\nSW – the spectral window in ppm for use in the simulation.\nν_0ppm – the 0 ppm peak frequency in Hz in the spectrum, for use in the simulation.\nconfig – a configuration file of type SHConfig.\n\nOptional inputs\n\nθs – This is a nested array for manually specifying the weight kernel bandwidth parameter (positive) for the convex clustering weights. The kernel is a square exponential kernel, i.e., exp(-θ*norm(X[i]-X[j])^2) for the edge weight between data points X[i] and X[j]. θs[n][i] is the positive weight kernel bandwidth of your choice for the n-th compound entry, i-th spin system. Use the default (i.e., leave this optional input alone) if you want to use the automated search strategy for the kernel bandwidth.\nγs – The sizing of this nested array is the same as θs, but for the sparsity-inducing parameter (positive, smaller means more resonance groups) for the convex clustering optimization problem. \nγ_bases – This needs to be assigned to defaultspinsysbuffer(config.γ_base, Phys),, but replace config.γ_base with your choice of the starting γ parameter. For use with the automated search strategy.\nγ_rates – This needs to be assigned to defaultspinsysbuffer(config.γ_rate, Phys),, but replace config.γ_base with your choice of the rate of increase for the next candidate γ parameter. For use with the automated search strategy. We've γ_next = γ_bases*γ_rate^(iter-1), where iter is the current search iteration. For use with the automated search strategy.\nγ_max_iters – This is similar to θs, but for the maximum allowed iterations in the automated search strategy for γ.\nlength_scale_bases and length_scale_rates are similar to γ_bases and γ_rates, but for length_scale = 1/(2*θ).\nmin_dynamic_ranges – The sizing of this nested array is the same as θs, but contain the stopping condition dynamic range value for which the kernel bandwidth automated search strategy terminates upon.\n\nOutputs\n\nAs::Vector{SHType{Float64}} – the simulated resonance intensities and frequencies, sub-system order of coherences, and resonance groups.\nRs – the partition tree used to generate the resonance groups. For diagnostic purposes.\nMSPs – the spin Hamiltonian matrices and coherence-related quantities. For diagnostic purposes.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"serializemixture","category":"page"},{"location":"api/#NMRHamiltonian.serializemixture","page":"Public API","title":"NMRHamiltonian.serializemixture","text":"function serializemixture(\n    As::Vector{SHType{T}},\n) where T\n\nReturns a Dict{Symbol, Any} object, which can then be used with file serialization packages for saving to disk.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"readbasechemshifts","category":"page"},{"location":"api/#NMRHamiltonian.readbasechemshifts","page":"Public API","title":"NMRHamiltonian.readbasechemshifts","text":"function readbasechemshifts(P::PhysicalParamsType{T})::Vector{Vector{T}} where T\n\nOutputs shifts, with index structure [spin system][cs index]. cs is in ppm. Singlet spin systems are at the end of shifts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"Public API","title":"Public API","text":"extractMEnuclei","category":"page"},{"location":"api/#NMRHamiltonian.extractMEnuclei","page":"Public API","title":"NMRHamiltonian.extractMEnuclei","text":"extractMEnuclei(     Phys::Vector{PhysicalParamsType{T}}, ) where T\n\nOutputs: IDs, cs, entry_IDs\n\nIDs::Vector{Vector{Int}}\n\nEach entry contains the set of nuclei labels that is associated with the corresponding entry in cs.\n\ncs::Vector{T}\n\nEach entry contains the chemical shift entry of a magnetically equivalent group of nuclei. The magnetic equivalent is based on the data stored in the ME field of the entries in Phy`.\n\nentry_IDs::Vector{Tuple{Int,Int}}\n\nEach entry contains a pair of integers that is associated with the corresponding entry in cs. The first integer is the molecule entry number. The second is the spin system number that the corresponding nuclei in IDs belongs to.\n\n\n\n\n\n","category":"function"},{"location":"return_vars/#Demo:-return-variables","page":"Demo: return variables","title":"Demo: return variables","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Run the code on the Demo: code walk-through first.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"We'll explore the various field names of the return variables for the simulation. We'll set look at the first compound (i.e., n = 1) and the first spin system (i.e., i = 1) for this demo. In Julia, set these variables:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"n = 1\ni = 1","category":"page"},{"location":"return_vars/#Resonance-components-result-for-the-n-th-compound-entry,-As[n]","page":"Demo: return variables","title":"Resonance components result for the n-th compound entry, As[n]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the As variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(As)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Vector{SHType{Float64}}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable As[n], which corresponds to the 1-st compound entry.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(As[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:αs, :Ωs, :Δc, :parts, :Δc_bar, :N_spins_sys, :fs, :SW, :ν_0ppm)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(As[n], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"9-element Vector{DataType}:\n Vector{Vector{Float64}} # αs\n Vector{Vector{Float64}} # Ωs\n Vector{Vector{Vector{Float64}}} # Δc\n Vector{Vector{Vector{Int64}}} # part\n Vector{Vector{Vector{Float64}}} # Δc_bar\n Vector{Int64} # N_spins_sys\n Float64 # fs, sampling frequency (in Hz) of the spectrometer used for this simulation (i.e., it is an input to the simulation, returned for book keeping).\n Float64 # SW, the spectral window (in ppm) of the spectrometer used for this simulation.\n Float64 # ν_0ppm, the 0 ppm resonance frequency used for this simulation.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Some of the field names are described below:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"αs[i][l]: resonance intensities for the i-th spin system, l-th resonance component. The intensities are relative to the number of nuclei for the n-th compound entry.\nΩs[i][l]: resonance frequencies for the i-th spin system, l-th resonance component. This is a radial frequency, which has units of radians. Divide by 2π to convert to Hz.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"NMRHamiltonian scales αs for a given n-th entry such that we should recover approximately the number of nuclei if we sum over the relative intensities. For example: ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"sum(As[1].αs[1])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"gives","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"4.994790368138611","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This number approaches 5 as relative_α_threshold is set to approach zero, the number of nuclei for the n == 1 compound entry of this demo, which is L-Glutamine. However, setting relative_α_threshold = 0.0 incurs significant computational burden, as every resonance component is kept, even if it has a tiny intensity. In practice, we recommend leaving relative_α_threshold == 0.01 or some other small number, but keep in mind that the sum of the relative intensities would not be exactly equal to the number of nuclei used to assemble the Hamiltonian.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Δc[i][l][j]: order of coherence for the i-th spin system, l-th resonance component, and j-th ME-modulo nuclei index. The set of 1-D arrays Δc[i] is the input set we pass to convex clustering to construct a partition. You can use your own clustering/partition construction algorithm; just overwrite Δc_bar[i] and part[i] accordingly with your results. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"part: a part is an element of a partition in combinatorics literature terminology. part[i][l] contains the resonance component indices (the l index from Δc) that belong in the part for the i-th spin system, j-th part. In NMRHamiltonian, a part of a spin system is called a resonance group, as it is a set of resonance components that share a similar degrees of freedom.\nΔc_bar[i][k][j]: representative order of coherence for the i-th spin system, k-th resonance group, and j-th ME-modulo nuclei index. The number of k index values is the number of parts that convex clustering returned.\nN_spins_sys[i]: the number of nuclei in the i-th spin system. These are not ME_modulo nuclei. This is used for normalization purposes for finalizing αs.","category":"page"},{"location":"return_vars/#Convex-clustering-result-for-the-n-th-compound-entry,-i-th-spin-system,-Rs[n][i]","page":"Demo: return variables","title":"Convex clustering result for the n-th compound entry, i-th spin system, Rs[n][i]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Each Rs[n][i] is generated by the inputs or results of the convex clustering on the input point set stored in As[n].Δc[i].","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the Rs variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(Rs)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Vector{Vector{PartitionSearchRecord{Float64}}}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable Rs[n][i], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(Rs[n][i])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:Gs, :γs, :chosen_ind_γ, :θs, :connectivity_label, :connectivity_parameter)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(Rs[n][i], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"6-element Vector{DataType}:\n Vector{Vector{Vector{Int64}}} # Gs, \n Vector{Float64} # γs\n Int64 # chosen_ind_γ\n Vector{Float64} # θs, list of weight kernel function bandwidths that was tested. Diagnostics for convex clustering.\n Symbol # connectivity_label, diagnostics for convex clustering.\n Symbol # connectivity_parameter, diagnostics for convex clustering.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Gs[m]: This is a partition that contains the indices of the input point set. It corresponds to the m-th level of the inverted partition tree generated by convex clustering. By inverted, we mean Gs[begin] is towards the leaf level, and Gs[end] is towards the root level. The leaf level is where every point in the input set is a part of the solution partition, and the root level is where there is only one part.\nγs[m]: The sparsity-inducing hyperparameter for a run of convex clustering, corresponding to the partition solution Gs[m].\nchosen_ind_γ: The tree level chosen to be the set of resonance groups for the n-th compound entry, i-th spin system. i.e., As[n].parts[i] = Rs[n][i].Gs[Rs[n][i].chosen_ind_γ].","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"The other field names of Rs concerns with convex clustering diagnostics and debugging, and isn't relevant for the operation of NMRHamiltonian.","category":"page"},{"location":"return_vars/#Spin-system-information-for-the-n-th-compound-entry,-MSPs[n]","page":"Demo: return variables","title":"Spin system information for the n-th compound entry, MSPs[n]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the MSPs variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(MSPs)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Vector{MoleculeSpinSystem{Float64}}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable Rs[n][i], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(MSPs[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:spin_systems, :singlet_intensities, :singlet_frequencies)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"spin_systems: Discussed shortly.\nsinglet_intensities[m]: The m-th singlet intensity of the n-th compound entry.\nsinglet_frequencies[m]: The m-th singlet (radial) frequency (in radians) of the n-th compound entry.","category":"page"},{"location":"return_vars/#Hamiltonian-for-the-n-th-compound-entry,-i-th-spin-system,-MSPs[n].spin_system[i]","page":"Demo: return variables","title":"Hamiltonian for the n-th compound entry, i-th spin system, MSPs[n].spin_system[i]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the MSPs[n].spin_systems[i] variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(MSPs[n].spin_systems[i])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"NMRHamiltonian.SpinSystem{Float64}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable MSPs[n].spin_systems[i], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(MSPs[n].spin_systems[i])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:intensities, :frequencies, :H, :coherence_mat, :coherence_state_pairs, :states, :partial_quantum_numbers, :quantum_numbers, :coherence_tol)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(MSPs[n].spin_systems[i], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"9-element Vector{DataType}:\n Vector{Float64} (alias for Array{Float64, 1}) # intensities\n Vector{Float64} (alias for Array{Float64, 1}) # frequencies\n NMRHamiltonian.Hamiltonian{Float64} # H\n Matrix{Float64} (alias for Array{Float64, 2}) # coherence_mat\n Vector{Tuple{Int64, Int64}} (alias for Array{Tuple{Int64, Int64}, 1}) # coherence_state_pairs\n Vector{Int64} (alias for Array{Int64, 1}) # states\n Vector{Vector{Float64}} (alias for Array{Array{Float64, 1}, 1}) # partial_quantum_numbers\n Vector{Float64} (alias for Array{Float64, 1}) # quantum_numbers\n Float64 # coherence_tol","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"intensities: These are all the resonance intensities that passed the (-1)-quantum coherence condition (within a numerical tolerance of coherence_tol). The αs intensities were created from intensities.\nfrequencies: Similar to intensities, but for resonance (radial) frequencies, in radians.\nH: information for the Hamiltonian matrix. The H.matrix is the Hamiltonian matrix. H.contributions is a 1-D array of two matrices that sum to H.matrix, each of the matrices corresponds to a term in the Hamiltonian equation in our manuscript. The H.eigenvalues and H.eigenvectors are the eigenpairs of H.matrix.\ncoherence_mat: this is the order of coherence as computed using the z-axis spin angular momentum.\ncoherence_state_pairs: this is the eigenstate pairs (sometimes denoted by {(r,s)} in our manuscript) that corresponds to each resonance component in intensities and frequencies.\nstates: the unique states in coherence_state_pairs.\npartial_quantum_numbers: the contributions to the quantum number of each state in states. One contribution from each quantum sub-system, where each sub-system is a ME-modulo nuclei index. These generate the order of coherence features Δc.\nquantum_numbers: the quantum numbers of an eigenstate, used to determine if a state-pair from coherence_state_pairs satisfies the (-1)-quantum coherence condition (within a numerical tolerance of coherence_tol). If it does, the state-pair creates a valid resonance component, and its intensity and frequency is computed and stored as an element of intensities and frequencies, respectively.","category":"page"},{"location":"return_vars/#Physical-chemistry-parameters-for-the-n-th-compound-entry,-Phys[n]","page":"Demo: return variables","title":"Physical chemistry parameters for the n-th compound entry, Phys[n]","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"First, we find out what data type the Phys[n] variable is. ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"typeof(Phys[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"NMRHamiltonian.PhysicalParamsType{Float64}","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Next, we display the list of field names for the variable Phys[n], which corresponds to the convex clustering results for the first compound entry, first spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"ns = propertynames(Phys[n])","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"(:H_IDs, :H_inds_sys, :cs_sys, :H_inds_singlets, :cs_singlets, :J_inds_sys, :J_inds_sys_local, :J_vals_sys, :ME)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"Let's see their respective data types:","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"collect( typeof( getfield(Phys[n], field_name) ) for field_name in ns )","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"This should show up in the REPL, and we added additional comments to show what the nested arrays index.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"9-element Vector{DataType}:\n Vector{Int64} # H_IDs\n Vector{Vector{Int64}} # H_inds_sys\n Vector{Vector{Float64}} # cs_sys\n Vector{Vector{Int64}} # H_inds_singlets\n Vector{Float64} # cs_singlets\n Vector{Vector{Tuple{Int64, Int64}}} # J_inds_sys\n Vector{Vector{Tuple{Int64, Int64}}} # J_inds_sys_local\n Vector{Vector{Float64}} # J_vals_sys\n Vector{Vector{Vector{Int64}}} # ME","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"H_IDs: The nuclei labels parsed from the physical chemistry file for the n-th compound entry.\nH_inds_sys[i]: The nuclei from a re-labelled H_IDs that are in the i-th spin system. The re-label starts from 1, and increments by 1.\ncs_sys[i]: The chemical shifts (in units ppm) that corresponds to the nuclei in H_inds_sys[i], for the i-th spin system.\nH_inds_singlets: The nuclei from a re-labelled H_IDs that generate singlet spin systems.\ncs_singlets: The chemical shifts (in units ppm) that corresponds to the nuclei in H_inds_singlets.\nJ_inds_sys[i]: Pairs of nuclei from H_inds_sys[i] such that each pair has a J-coupling value for the i-th spin system.\nJ_inds_sys_local[i]: This is a version of J_inds_sys[i] but the nuclei indices are re-labelled to start from 1, i.e. this is a re-labelling of the nuclei for the i-th spin system.\nJ_vals_sys: J-coupling values in Hz, corresponds to the nuclei in J_inds_sys[i] and J_inds_sys_local[i].\nME[i][m]: The nuclei indices from a re-labelled H_IDs (so that it starts from 1, increments by 1) for the m-th non-singleton ME-modulo nuclei index in the i-th spin system. This means ME[i][m] contains some nuclei labels that together form the m-th set of nuclei such that it contains only nuclei that are magnetically equivalent to each other, and this m-th set of nuclei is the largest possible set. Non-singleton means that ME[i][m] does not include nucleus that are not magnetically equivalent to anyone else; any nucleus is magnetically equivalent to itself, and we exclude it to be in ME[i][m]. For example, if Phys[n].ME[i] contains ","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"2-element Vector{Vector{Int64}}:\n [7, 5, 6] # assign to j == 1\n [1, 2, 3] # assign to j == 2.\n # The other values of j's are assigned according to ascending numerical value of whatever nuclei labels are left in this spin system.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"then it means the n-th compound entry, i-th spin system has two non-singleton magnetically equivalent set of nuclei. The first set of nuclei is nuclei {7,5,6} and the second set is nuclei {1,2,3}. If there are 8 nuclei for this compound entry, then nuclei 4 and 8 are both not magnetically equivalent to any other nuclei that isn't itself. The ME-module index j for this spin system would be {1,2,3,4}, with j == 1 representing nuclei {7,5,6}, j == 2 representing nuclei {1,2,3}, j == 3 representing nucleus 4, j == 4 representing nucleus 8.","category":"page"},{"location":"return_vars/#Store-simulated-variables","page":"Demo: return variables","title":"Store simulated variables","text":"","category":"section"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"JSON: in this demo, we use the JSON3.jl library for loading JSON. Please make sure it is installed before running the following code.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"# store.\nfile_name = \"test.json\"\nS = NMRHamiltonian.serializemixture(As)\nNMRHamiltonian.saveasJSON(file_name, S)\n\n# load.\nimport JSON 3\nfile_path = file_name\njson_string = read(file_path)\nW = JSON3.read(json_string)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"You can also use BSON.jl.","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"# store.\nfile_name = \"test.bson\"\nS = NMRHamiltonian.serializemixture(As)\nBSON.bson(file_name, S)\n\n# load.\nW = BSON.load(file_name)","category":"page"},{"location":"return_vars/","page":"Demo: return variables","title":"Demo: return variables","text":"A round-trip test routine is in the test folder of the NMRHamiltonian repository. See the functions roundtripJSON() and roundtripBSON() in that folder for more details on the test.","category":"page"},{"location":"demo_code/#Demo:-code-walk-through","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"","category":"section"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"For those who prefer working with source files instead of the Julia REPL and notebooks, this demo follows the script examples/demo.jl, which is derived from examples/simulate_SH.jl in the NMRHamiltonian repository. In this demo, we load the physical chemistry parameters and alias mapping files, then simulate the resonance frequency and intensity, followed by an application of the convex clustering to partition the resonance components into resonance groups.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"First, load the libraries. You can use using (loads NMRHamiltonian into current namespace) or import (loads NMRHamiltonian into its own namespace NMRHamiltonian). We use the latter in this demo.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"import NMRHamiltonian\nHAM = NMRHamiltonian # so we don't need to type NMRHamiltonian. everytime we reference something from this library.\n\n\nusing DataDeps, Tar, CodecZlib\n\nusing LinearAlgebra\nimport PythonPlot # do Pkg.add(\"PythonPlot\") if you're missing this library.\n\n# actual values from Bruker machines. Curated from BMRB experiments.\nfunction fetchsamplemachinesettings(tag)\n\n    fs = 14005.602240896402\n    SW = 20.0041938620844\n    ν_0ppm = 10656.011933076665\n\n    if tag == \"700\"\n        # machine values taken from the BMRB 700 MHz 20 mM glucose experiment.\n        fs = 14005.602240896402 # in Hz.\n        SW = 20.0041938620844 # spectral window, in ppm.\n        ν_0ppm = 10656.011933076665 # in Hz, where the zero ppm is detected in the experiment. Not used for this demo.\n\n    elseif tag == \"600\"\n        ## machine values from a 600 MHz experiment: bmse000915, methionine.\n        fs = 9615.38461538462\n        SW = 16.022093454391\n        ν_0ppm = 6685.791496181313\n\n    elseif tag == \"900\"\n        ## machine values from a 900 MHz experiment: GISSMO, leucine entry.\n        fs = 14423.0769230769\n        SW = 16.0300195009073\n        ν_0ppm = 10160.027322585376\n\n    elseif tag == \"500\"\n        fs = 6493.50649350649\n        SW = 12.9911090156122\n        ν_0ppm = 4035.6644246816795\n\n    elseif tag == \"400\"\n\n        ### 400 MHz, bmse000297, ethanol.\n        fs = 4807.69230769231\n        SW = 12.0152693165838\n        ν_0ppm = 2884.905244600881\n    end\n\n    return fs, SW, ν_0ppm\nend\n\n# the same function for ensuring the dataset at 10.5281/zenodo.8174261 is downloaded.\nfunction getdatapath()::String\n\n    dataset_alias = \"AI4DBiological-Systems_NMR_data\" # don't use spaces or 'strange' symbols like commas, colons, etc.\n    archive_file_name = \"nmr_physical_parameters_dataset.tar.gz\" # the filename on the data repository that we download.\n    url = \"https://zenodo.org/record/8174261/files/nmr_physical_parameters_dataset.tar.gz?download=1\"\n\n    register(DataDep(\"$dataset_alias\",\n        \"\"\"\n        Dataset: Selected BMRB 1D 1H NMR data and physical chemistry values compiled from literature\n        Author: Roy Chih Chung Wang\n        License: [Creative Commons Attribution Non Commercial Share Alike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode)\n        DOI: 10.5281/zenodo.8174261\n\n        Description:\n        The experiments were downloaded from BMRB,\n        The physical chemistry parameters data and sample configuration-related files were collected, organized, converted or manually entered in as JSON files by Roy.\n        The physical chemistry parameters, i.e., chemical shift and J-coupling values, are from two sources:\n        - GISSMO: (https://gissmo.bmrb.io/ acccessed Mar. 2023). See Dashti, et. al. DOI: 10.1021/acs.analchem.8b02660 and DOI: 10.1021/acs.analchem.7b02884 for more details.\n        - From Govindaraju, et. al.'s work: DOI: 10.1002/1099-1492(200005)13:3<129::AID-NBM619>3.0.CO;2-V\n\n        Please cite the data sources and this data repository if you find the contents helpful for your work. See the Zenodo DOI entry for more description.\n        \"\"\",\n        url\n    ));\n\n    #readdir(datadep\"AI4DBiological-Systems NMR data\") # have to manually type out the alias. Does not allow string variable substitution.\n    local_dataset_archive_path = @datadep_str(\"$dataset_alias\") # call the actual macro to allow string variable substitution.\n\n    # extract archive, then delete. Do this only if archive file still exists.\n\n    root_data_path = joinpath(local_dataset_archive_path, \"contents\")\n    \n    if isfile(joinpath(local_dataset_archive_path, archive_file_name))\n        t = @task begin; ispath(root_data_path) || mkpath(root_data_path); end\n        schedule(t); wait(t)\n    \n        #t = @task begin; Tar.extract(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        t = @task begin; extractuncompress(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        schedule(t); wait(t)\n        rm(joinpath(local_dataset_archive_path, archive_file_name)) # delete the archive file.\n    end\n\n    return root_data_path\n\n    # # return root_data_path. however, this unpacks in the current working directory!\n    # archive_file_path = joinpath(local_dataset_archive_path, archive_file_name)\n    # if isfile(archive_file_path)\n    #     DataDeps.unpack(archive_file_path)\n    # end\n    #return local_dataset_archive_path\nend\n\nfunction extractuncompress(src_path, dest_path)\n    tar_gz = open(src_path)\n    tar = GzipDecompressorStream(tar_gz)\n    dir = Tar.extract(tar, dest_path)\n    close(tar)\n    \n    return dir\nend\n\n# This was tested in a REPL environment, not a notebook environment. You might need to modify this for notebooks to get it to display the plots.\nPythonPlot.close(\"all\")\nfig_num = 1\nPythonPlot.matplotlib[\"rcParams\"][:update]([\"font.size\" => 22, \"font.family\" => \"serif\"])\n\nT = Float64","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"The variable molecule_entries contain compound aliases. For this demo, any alias in the molecule_name_mapping/select_molecules.json file from 10.5281/zenodo.8174261 would work.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"### user inputs.\n\nmolecule_entries = [\"L-Glutamine\"; \"L-Valine\"; \"L-Phenylalanine\"; \"DSS\"]\n\n# machine values taken from the BMRB 700 MHz 20 mM glucose experiment.\nfs, SW, ν_0ppm = fetchsamplemachinesettings(\"700\")\n\n## pull the sample coupling values into dictionary structures.\n# use DataDeps.jl and Tar.jl to download and extract the sample coupling values.\nroot_data_path = getdatapath() # coupling values data repository root path\n\nH_params_path = joinpath(root_data_path, \"coupling_info\") # folder of coupling values. # replace with your own values in actual usage.\n\nmolecule_mapping_root_path = joinpath(root_data_path, \"molecule_name_mapping\")\nmolecule_mapping_file_path = joinpath(molecule_mapping_root_path, \"select_molecules.json\")\n#molecule_mapping_file_path = joinpath(molecule_mapping_root_path, \"GISSMO_names.json\")\n\n\n# # These produce a aprtition tree over the searched γ values for many molecule entries.\nconfig_SH = HAM.SHConfig(\n    T;\n    coherence_tol = 0.01, # set to a small number. must be larger than zero. 0.01 seemed to work across our test simulation configurations.\n    relative_α_threshold = 0.01, # the larger it is, the more resonance components would be dropped for computation speed. However, setting it to 0 would keep every resonance component even if it had a very small intensity. 0.01 seemed to work across our test simulation configurations.\n    max_partition_size_offset = 0,\n    partition_rate = 2.0,\n    γ_base = 0.01,\n    γ_rate = 1.05,\n    max_iter_γ = 100,\n    fully_connected_convex_clustering = false, #  overides all knn-related optional inputs\n    length_scale_base = 10.0,\n    length_scale_rate = 0.7,\n    min_dynamic_range = 0.95,\n    cc_gap_tol = 1e-8, # set this much smaller than assignment_zero_tol to get partition tree, this is the stopping gradient residual of the convex clustering algorithm.\n    cc_max_iters = 300,\n    assignment_zero_tol = 1e-3,\n    report_γ_cost = true,\n    verbose_kernel = true,\n)","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"Now, load the parameters, simulate the resonance components, and partition into resonance groups.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"# read the physical parameters from file, from via the DataDeps routine from \"helpers/data.jl\".\nPhys = HAM.getphysicalparameters(\n    Float64,\n    molecule_entries,\n    H_params_path,\n    molecule_mapping_file_path;\n    unique_cs_atol = 1e-6,\n)\n# You can tweak the J-coupling or chemical shift values of Phys manually if desired, before calling simulate(). We won't tweak anything in this demo.\n\n# Assemble and eigendecompose the Hamiltonian, get frequencies and intensities for each resonance component, and partition the comonents into resonance groups.\nAs, Rs, MSPs = HAM.simulate(\n    Phys,\n    molecule_entries,\n    fs,\n    SW,\n    ν_0ppm,\n    config_SH,\n)","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"Now, we'll plot the absorption Lorentzian spectrum of the simulated resonance frequencies and intensities. We'll have to make up a T2 relaxation value, which corresponds to the component width.","category":"page"},{"location":"demo_code/","page":"Demo: code walk-through","title":"Demo: code walk-through","text":"### visualize a target molecule and spin group, given a T-2 decay parameter.\nλ0 = 3.4 # make up a T-2 decay parameter for this plotting example.\nmolecule_select = 1\nspin_system_select = 1\nppm_offset = 0.2 # for display padding.\nN_viz = 50000 # this many points to plot\n\na = As[molecule_select].αs[spin_system_select]\nF = As[molecule_select].Ωs[spin_system_select]\n\nhz2ppmfunc = uu->(uu - ν_0ppm)*SW/fs # Hz to ppm conversion. This is useful to remember.\nppm2hzfunc = pp->(ν_0ppm + pp*fs/SW) # ppm to Hz conversion. This is useful to remember.\n\nΩS_ppm = hz2ppmfunc.( F ./ (2*π) ) # convert to radial frequency.\nΩS_ppm_sorted = sort(ΩS_ppm)\n\nu_min = ppm2hzfunc(ΩS_ppm_sorted[1] - ppm_offset)\nu_max = ppm2hzfunc(ΩS_ppm_sorted[end] + ppm_offset)\n\nP_min = hz2ppmfunc(u_min)\nP_max = hz2ppmfunc(u_max)\n\nP = LinRange(P_min, P_max, N_viz)\nU = ppm2hzfunc.(P)\nU_rad = U .* (2*π)\n\n# absorption Lorentzian.\nfunction evalzerophasecl1Darray(u_rad, αs::Vector{T}, Ωs::Vector{T}, λ::T)::Complex{T} where T <: AbstractFloat\n\n    out = zero(Complex{T})\n    for l = 1:length(αs)\n        out += evalzerophaseclpartitionelement(u_rad, αs[l], Ωs[l], λ)\n    end\n\n    return out\nend\n\nfunction evalzerophaseclpartitionelement(r,\n    α::T, Ω::T, λ::T)::Complex{T} where T <: AbstractFloat\n\n    out = α/(λ+im*(r-Ω))\n\n    return out\nend\n\nq = uu->evalzerophasecl1Darray(uu, a, F, λ0)\nq_U = q.(U_rad)\n\n# plot.\nPythonPlot.figure(fig_num)\nfig_num += 1\n\nPythonPlot.plot(P, real.(q_U))\nPythonPlot.gca().invert_xaxis()\n\nPythonPlot.ylabel(\"real part\")\n#PythonPlot.legend()\nPythonPlot.title(\"spectrum of $(molecule_entries[molecule_select]), spin system $(spin_system_select)\")","category":"page"},{"location":"#NMRHamiltonian.jl","page":"Overview","title":"NMRHamiltonian.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"NMRHamiltonian is a library for simulating the resonance frequencies and relative intensities of compounds in isotropic liquid. It is intended for 1D 1H NMR, which is a spin-1/2 NMR. ","category":"page"},{"location":"#Table-of-contents","page":"Overview","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Pages = [\"index.md\"]\nDepth = 5","category":"page"},{"location":"#Install","page":"Overview","title":"Install","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"NMRHamiltonian is hosted on a custom Julia registry. We need to add that before installing NMRHamiltonian: ","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.Registry.add(RegistrySpec(url = \"https://github.com/AI4DBiological-Systems/PublicJuliaRegistry\"))\nPkg.add(\"NMRHamiltonian\")","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"To update this package once it is installed, do","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using Pkg\nPkg.update(\"NMRHamiltonian\")","category":"page"},{"location":"#Important-exported-functions","page":"Overview","title":"Important exported functions","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The following functions are the focus of NMRHamiltonian:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"getphysicalparameters() given a list of compound aliases, parse the physical chemistry parameters from file to data structure.\nSHConfig() assembles the simulation configuration container variable. This is a constructor to a composite data type (i.e., this data type is like the C programming language's struct).\nsimulate() the outputs of getphysicalparameters() and SHConfig(), and returns a data structure that contain the simulated frequencies and relative intensities for each resonance comonents, and their resonance groups.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is not a full quantum simulation of the NMR spectrum; only the frequencies, intensities, and this partition of the resonance components called a set of resonance groups is returned.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"See the demo pages for an example walk-through of how to use this library.","category":"page"},{"location":"#Julia-Basics","page":"Overview","title":"Julia Basics","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Read the Julia documentation for installing Julia packages.\nWe use 1-indexing for addressing arrays here, but you can use [begin + n] instead of [n] if you wish to use a 0-indexing index n. ","category":"page"},{"location":"#A-compiled-list-of-physical-chemistry-parameters","page":"Overview","title":"A compiled list of physical chemistry parameters","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The getphysicalparameters() function in NMRHamiltonian requires the user to supply it with a list of compound aliases, each of which is a string called an entry, as well as the corresponding file path of each entry to a JSON file that stores its physical chemistry parameters. These parameters are the chemical shift and J-coupling values of an compound, as we are only concerned with spin-1/2 NMR in isotropic liquid in NMRHamiltonian. As some of these values change as a function of ambient temperature, pH, spectrometer frequency, one can have multiple entries that describe the same compound for different experimental or spectrometer configurations.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The demo and test scripts for NMRHamiltonian.jl requires the compiled list of parameters at 10.5281/zenodo.8174261, but you are encouraged to devise your own that follows its JSON format. You'll need a alias-to-file-path mapping file, which is the molecule_name_mapping/selected_molecules.json file from this dataset. You'll also need the individual parameter files for each compound at a certain experimental or spectrometer configurations, which are the files in the coupling_info folder from this dataset. See these files to get a sense of how the format is like.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For the parameter files, the JSON file structure goes like this:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"{\n       \"J-coupling\": [\n                       {\n                            \"ID2\": 9,\n                            \"ID1\": 8,\n                          \"value\": -12.531894\n                       },\n                       {\n                            \"ID2\": 10,\n                            \"ID1\": 8,\n                          \"value\": 3.511369\n                       },\n                       {\n                            \"ID2\": 10,\n                            \"ID1\": 9,\n                          \"value\": 5.979\n                       }\n                     ],\n   \"chemical shift\": [\n                       {\n                          \"value\": 3.9744,\n                             \"ID\": 8\n                       },\n                       {\n                          \"value\": 3.9352,\n                             \"ID\": 9\n                       },\n                       {\n                          \"value\": 3.83016,\n                             \"ID\": 10\n                       }\n                     ]\n}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This is the L-Serine_mod.json file in coupling_info from the dataset. This indicates that there are J-couplings (nucleus 1 ID, nucleus 2 ID, J-coupling value in Hz) = (8, 9, -12.531894), (8, 10, 3.511369), (9, 10, 5.979). There are chemical shifts for each nuclei: (8, 3.9744 ppm), (9, 3.9352 ppm), (10, 3.83016 ppm).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can construct ficticious compound entries and simulate it, just to see what the resonance frequencies and intensities might look like.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For the mapping file, it follows the format:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"{\n    \"Dopamine - 500 MHz\": {\n        \"notes\": \"http://gissmo.bmrb.io/entry/bmse000909/simulation_1\",\n        \"file name\": \"bmse000909_simulation_1.json\"\n    },\n    \"L-Cystine\": {\n        \"notes\": \"http://gissmo.bmrb.io/entry/bmse000035/simulation_1\",\n        \"file name\": \"bmse000035_simulation_1.json\"\n    },\n}","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It means that the parameter file for compound alias \"Dopamine - 500 MHz\" is bmse000909_simulation_1.json in the nuclei parameter file path folder, which together with the file path for the mapping file, are inputs to the getphysicalparameters() function in this library. We will go over this function in the demo.","category":"page"},{"location":"#Citation","page":"Overview","title":"Citation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Please cite 10.5281/zenodo.8174261 and the appropriate references within if you use any physical chemistry values from it. The references to the original data sources from which these values were curated from are also in the instructions.","category":"page"},{"location":"#Download-a-NMR-parameters-dataset-via-DataDeps.jl","page":"Overview","title":"Download a NMR parameters dataset via DataDeps.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Run the following commands to load the getdatapath() function into Julia REPL, which calls DataDeps.jl to download and uses Tar.jl and CodecZlib to extract the files on your local machine. If you usually use a source file workflow, these commands are stored in examples/helpers/data.jl in the NMRHamiltonian repository.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using DataDeps, Tar, CodecZlib\n\n\nfunction getdatapath()::String\n\n    dataset_alias = \"AI4DBiological-Systems_NMR_data\" # don't use spaces or 'strange' symbols like commas, colons, etc.\n    archive_file_name = \"nmr_physical_parameters_dataset.tar.gz\" # the filename on the data repository that we download.\n    url = \"https://zenodo.org/record/8174261/files/nmr_physical_parameters_dataset.tar.gz?download=1\"\n\n    register(DataDep(\"$dataset_alias\",\n        \"\"\"\n        Dataset: Selected BMRB 1D 1H NMR data and physical chemistry values compiled from literature\n        Author: Roy Chih Chung Wang\n        License: [Creative Commons Attribution Non Commercial Share Alike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode)\n        DOI: 10.5281/zenodo.8174261\n\n        Description:\n        The experiments were downloaded from BMRB,\n        The physical chemistry parameters data and sample configuration-related files were collected, organized, converted or manually entered in as JSON files by Roy.\n        The physical chemistry parameters, i.e., chemical shift and J-coupling values, are from two sources:\n        - GISSMO: (https://gissmo.bmrb.io/ acccessed Mar. 2023). See Dashti, et. al. DOI: 10.1021/acs.analchem.8b02660 and DOI: 10.1021/acs.analchem.7b02884 for more details.\n        - From Govindaraju, et. al.'s work: DOI: 10.1002/1099-1492(200005)13:3<129::AID-NBM619>3.0.CO;2-V\n\n        Please cite the data sources and this data repository if you find the contents helpful for your work. See the Zenodo DOI entry for more description.\n        \"\"\",\n        url\n    ));\n\n    #readdir(datadep\"AI4DBiological-Systems NMR data\") # have to manually type out the alias. Does not allow string variable substitution.\n    local_dataset_archive_path = @datadep_str(\"$dataset_alias\") # call the actual macro to allow string variable substitution.\n\n    # extract archive, then delete. Do this only if archive file still exists.\n\n    root_data_path = joinpath(local_dataset_archive_path, \"contents\")\n    \n    if isfile(joinpath(local_dataset_archive_path, archive_file_name))\n        t = @task begin; ispath(root_data_path) || mkpath(root_data_path); end\n        schedule(t); wait(t)\n    \n        #t = @task begin; Tar.extract(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        t = @task begin; extractuncompress(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end\n        schedule(t); wait(t)\n        rm(joinpath(local_dataset_archive_path, archive_file_name)) # delete the archive file.\n    end\n\n    return root_data_path\n\n    # # return root_data_path. however, this unpacks in the current working directory!\n    # archive_file_path = joinpath(local_dataset_archive_path, archive_file_name)\n    # if isfile(archive_file_path)\n    #     DataDeps.unpack(archive_file_path)\n    # end\n    #return local_dataset_archive_path\nend\n\nfunction extractuncompress(src_path, dest_path)\n    tar_gz = open(src_path)\n    tar = GzipDecompressorStream(tar_gz)\n    dir = Tar.extract(tar, dest_path)\n    close(tar)\n    \n    return dir\nend","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Now, run this function to download and extract the data.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"getdatapath()","category":"page"},{"location":"#Terminology","page":"Overview","title":"Terminology","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A ME-modulo nuclei index corresponds to a maximal set of nuclei where each nucleus is magnetically equivalent (ME) with all other nucleus in that maximal set. For example: if compound X has 10 nuclei contributing to its 1D 1H NMR spectrum, but nucleus #2 and #5 are ME, the other nucleus do not form ME with each other, then we can re-label the nuclei indices i = 1, 2, ..., 10 to the ME-modulo nuclei index j = 1, 2, ..., 9, with j = 2 denoting the set of nuclei {i == 2, i == 5}. The order of coherences-related quantities in NMRHamiltonian use ME-modulo nuclei indices as oppose to the nuclei indices.\nA radial frequency in units of radians is a frequency in Hz multiplied by 2π.\nA resonance group is a set of resonance components that have similar degrees-of-freedom. The set of resonance groups of a spin system is a partition of the resonance components for that spin system.\nA part is an element of a partition of a set X. This means a part is a subset of X.\nThroughout this documentation, we use x == y to mean the value in variable x equals to the value in variable y. We use x = y to mean we assign the variable x the value  y.","category":"page"},{"location":"#License","page":"Overview","title":"License","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"NMRHamiltonian has the Mozilla Public License Version 2.0.","category":"page"},{"location":"#Authors","page":"Overview","title":"Authors","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Code author:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Roy Chih Chung Wang","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Supervisors:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Dave Campbell (Carleton University, Bank of Canada)\nMiroslava Čuperlović-Culf (National Research Council of Canada)","category":"page"},{"location":"#Funding","page":"Overview","title":"Funding","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"This projected was funded by the AI-for-Design Challenge Program from the National Research Council of Canada.","category":"page"}]
}
