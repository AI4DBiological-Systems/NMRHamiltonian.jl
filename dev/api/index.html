<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · NMRHamiltonian.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NMRHamiltonian.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>Public API</a></li><li><a class="tocitem" href="../demo_code/">Demo: code walk-through</a></li><li><a class="tocitem" href="../return_vars/">Demo: return variables</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-References"><a class="docs-heading-anchor" href="#Function-References">Function References</a><a id="Function-References-1"></a><a class="docs-heading-anchor-permalink" href="#Function-References" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="NMRHamiltonian.getphysicalparameters" href="#NMRHamiltonian.getphysicalparameters"><code>NMRHamiltonian.getphysicalparameters</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getphysicalparameters(
    ::Type{T},
    target_entries::Vector{String},
    H_params_path::String,
    molecule_mapping_file_path;
    unique_cs_atol = 1e-6,
) where T &lt;: AbstractFloat</code></pre><p>Assemble the J-coupling and chemical shift values from JSON files for the specified molecules.</p><p><strong>Nomenclature</strong></p><p>One set of J-coupling and one set of chemical shift values for a molecule is what NMRHamiltonian.jl calls a molecule entry.</p><p>It is common to see different J-coupling values of the same molecule reported in literature for similar experimental conditions.  NMRHamiltonian.jl requires one to record each instance as separate molecule entry.</p><p>Every molecule entry is recorded as a separate JSON file with some arbitrary file name the data collector wants to use. An additional name-mapping JSON file is needed to translate what the NMRHamiltonian.jl user wants to label the entries to what is the data collector chose to name the JSON files. The name-mapping JSON file is likely to require manual set up.</p><p><strong>Inputs</strong></p><ul><li><code>::Type{T}</code>       – The <code>AbstractFloat</code> datatype to use for storing floating point data. A viable input here is <code>Float64</code>, which specifies double precision floating point numbers are to be used.</li><li><code>target_entries</code>  – list of molecule entry names.</li><li><code>H_params_path</code>   – path to the directory that contain the J-coupling and chemical shift JSON files. Each file corresponds to one entry of a molecule, and has a set of chemical shifts and J-coupling information in the JSON dictionary format.   <code>ID1</code> and <code>ID2</code> are JSON dictionary keys that specify the spin nucleus label for J-coupling values, and <code>ID</code> is the nucleus label for chemical shift values. The following is an example of the JSON format for a L-Histidine entry:</li></ul><pre><code class="nohighlight hljs">{
       &quot;J-coupling&quot;: [
                       {
                            &quot;ID2&quot;: 13,
                            &quot;ID1&quot;: 12,
                          &quot;value&quot;: -15.350518
                       },
                       {
                            &quot;ID2&quot;: 16,
                            &quot;ID1&quot;: 12,
                          &quot;value&quot;: 7.63377
                       },
                       {
                            &quot;ID2&quot;: 16,
                            &quot;ID1&quot;: 13,
                          &quot;value&quot;: 5.029267
                       }
                     ],
   &quot;chemical shift&quot;: [
                       {
                          &quot;value&quot;: 3.18747,
                             &quot;ID&quot;: 12
                       },
                       {
                          &quot;value&quot;: 3.26837,
                             &quot;ID&quot;: 13
                       },
                       {
                          &quot;value&quot;: 7.14078,
                             &quot;ID&quot;: 14
                       },
                       {
                          &quot;value&quot;: 8.02487,
                             &quot;ID&quot;: 15
                       },
                       {
                          &quot;value&quot;: 3.9967,
                             &quot;ID&quot;: 16
                       }
                     ]
}</code></pre><ul><li><code>molecule_mapping_file_path</code>   – the files in <code>H_params_path</code> might not be named in a manner for the user to know which molecule entry corresponds to which JSON file. Therefore, the user should further define a single JSON file that encodes this mapping.   Example: if the file <code>bmse000976_simulation_1.json</code> corresponds to the molecule entry &quot;L-Histidine&quot; and the file <code>Histidine_Govindaraju_2000.json</code> corresponds to the molecule entry &quot;L-Histidine - Govindaraju&quot;, and suppose the user only wants to target these two entries, i.e. <code>target_entries</code> contain only these two entries. Then the following entry-filename-mapping JSON file should be used, and <code>molecule_mapping_file_path</code> should be the path to this entry-filename-mapping file.</li></ul><pre><code class="nohighlight hljs">{
    &quot;L-Histidine&quot;: {
        &quot;notes&quot;: &quot;http://gissmo.bmrb.io/entry/bmse000976/simulation_1&quot;,
       &quot;file name&quot;: &quot;bmse000976_simulation_1.json&quot;
    },
    &quot;L-Histidine - Govindaraju&quot;: {
        &quot;notes&quot;: &quot;https://pubmed.ncbi.nlm.nih.gov/10861994/&quot;,
       &quot;file name&quot;: &quot;Histidine_Govindaraju_2000.json&quot;
    }
}</code></pre><p><strong>Optional inputs</strong></p><ul><li><code>unique_cs_atol</code>   – Two chemical shift values in the same JSON file are assigned the same chemical shift value to both nuclei if the two values in the file are less than <code>unique_cs_atol</code>.</li></ul><p><strong>Outputs</strong></p><ul><li><p><code>Phys::Vector{PhysicalParamsType{Float64}</code>    – list of the data type <code>PhysicalParamsType</code> that contain chemical shift and J-coupling information for each of the molecule entries in <code>target_entries</code>.</p></li><li><p><code>dict_molecule_to_filename</code>                   – the dictionary that maps molecule entries to meta information such as their corresponding JSON filenames</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/settings/front_end.jl#L431-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMRHamiltonian.SHConfig" href="#NMRHamiltonian.SHConfig"><code>NMRHamiltonian.SHConfig</code></a> — <span class="docstring-category">Type</span></header><section><div><p>function SHConfig(     ::Type{T};     coherence<em>tol = 0.01,     relative</em>α<em>threshold = 0.01,     max</em>partition<em>size</em>offset::Integer = 0,     partition<em>rate::Real = 2.0,     #search</em>θ::Bool = true,     #search<em>γ::Bool = true,     #θ</em>default = 0.0,     γ<em>base = 0.1,     γ</em>rate = 1.05,     max<em>iter</em>γ = 100,     fully<em>connected</em>convex<em>clustering = false, #  overides all knn-related optional inputs     max</em>connected<em>components</em>offset = -1,     starting<em>manual</em>knn = 60,     length<em>scale</em>base = 10.0,     length<em>scale</em>rate = 0.7,     min<em>dynamic</em>range = 0.95,     cc<em>gap</em>tol = 1e-8,     cc<em>max</em>iters = 300,     assignment<em>zero</em>tol = 1e-3,     report<em>γ</em>cost::Bool = true,     verbose_kernel::Bool = true,     )::SHConfig{T} where T</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/autogen.jl#L28-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMRHamiltonian.simulate" href="#NMRHamiltonian.simulate"><code>NMRHamiltonian.simulate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">simulate(
    part_algs::Vector{Vector{PartitionAlgorithmType}},
    names::Vector{String},
    fs::T,
    SW::T,
    ν_0ppm::T,
    Phys::Vector{PhysicalParamsType{T}},
    configs::Vector{SHsConfigType{T}}
    ) where T &lt;: AbstractFloat</code></pre><p>Performs spin hamiltonian simulation and resonance group partitioning of the molecule entries in <code>names</code>.</p><p><strong>Inputs</strong></p><ul><li><code>part_algs::Vector{Vector{PartitionAlgorithmType}}</code></li></ul><p>Element <code>[n][i]</code> is the partition algorithm config molecule entry <code>n</code>, non-singlet spin system <code>i</code>.</p><ul><li><code>names::Vector{String}</code></li></ul><p>List of molecule entries.</p><ul><li><code>fs</code>Sampling frequency of the spectrometer, in Hz. This is the rate at which the complex-valued free-induction decay signal is sampled at. An example value is around 14005.6 Hz for a 700 MHz spectrometer.</li></ul><ul><li><code>SW</code>Spectral window in ppm for the spectrometer. An example value is around 20.004 ppm for a 700 MHz spectrometer.</li></ul><ul><li><code>ν_0ppm</code>The 0 ppm reference frequency, in Hz. An example value is around 10656.01 Hz for a spectrometer with <code>SW</code> ≈ 20.004 ppm and <code>fs</code> ≈ 14005.6 Hz.</li></ul><ul><li><code>Phys::Vector{PhysicalParamsType{T}}</code></li></ul><p>List of chemical shift and J-coupling information for each molecule entry.</p><ul><li><code>configs::Vector{SHsConfigType{T}}</code></li></ul><p>List of spin Hamiltonian simulation configurations for each molecule entry.</p><p><strong>Outputs</strong></p><ul><li><code>As::SHType{T}</code></li></ul><p>A list of spin Hamiltonian result data structure variables. </p><ul><li><code>Rs::Vector{Vector{PartitionSearchRecord}}</code></li></ul><p>A list of iterative search results for the partitioning algorithm. This variable is only useful if an iterative search was done for regulariation parameter γ or/and kernel hyperparameter θ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/SH/front_end.jl#L1-L44">source</a></section><section><div><pre><code class="nohighlight hljs">simulate(
    Phys::Vector{PhysicalParamsType{T}},
    molecule_entries::Vector{String},
    fs::T,
    SW::T,
    ν_0ppm::T,
    config::SHConfig;

    θs::Vector{Vector{T}} = defaultspinsysbuffer(convert(T,Inf), Phys), # non-finite value means use search strategy.
    γs::Vector{Vector{T}} = defaultspinsysbuffer(convert(T,Inf), Phys),

    γ_bases = defaultspinsysbuffer(config.γ_base, Phys),
    γ_rates = defaultspinsysbuffer(config.γ_rate, Phys),
    γ_max_iters = defaultspinsysbuffer(config.max_iter_γ, Phys),

    length_scale_bases = defaultspinsysbuffer(config.length_scale_base, Phys),
    length_scale_rates = defaultspinsysbuffer(config.length_scale_rate, Phys),
    min_dynamic_ranges = defaultspinsysbuffer(config.min_dynamic_range, Phys),
) where T &lt;: AbstractFloat</code></pre><p>Simulate the resonance components&#39; intensities and frequencies, compute order of coherences for each component, and group the components into resonance groups.</p><p><strong>Inputs</strong></p><ul><li><code>Phys</code> – A <code>Vector</code> of physical chemistry parameters, e.g. the output of getphysicalparameters().</li><li><code>molecule_entries</code> – A <code>Vector</code> of compound entries.</li><li><code>fs</code> – the sampling frequency in Hz for use in the simulation.</li><li><code>SW</code> – the spectral window in ppm for use in the simulation.</li><li><code>ν_0ppm</code> – the 0 ppm peak frequency in Hz in the spectrum, for use in the simulation.</li><li><code>config</code> – a configuration file of type <code>SHConfig</code>.</li></ul><p><strong>Optional inputs</strong></p><ul><li><p><code>θs</code> – This is a nested array for manually specifying the weight kernel bandwidth parameter (positive) for the convex clustering weights. The kernel is a square exponential kernel, i.e., <code>exp(-θ*norm(X[i]-X[j])^2)</code> for the edge weight between data points <code>X[i]</code> and <code>X[j]</code>. θs[n][i] is the positive weight kernel bandwidth of your choice for the n-th compound entry, i-th spin system. Use the default (i.e., leave this optional input alone) if you want to use the automated search strategy for the kernel bandwidth.</p></li><li><p><code>γs</code> – The sizing of this nested array is the same as θs, but for the sparsity-inducing parameter (positive, smaller means more resonance groups) for the convex clustering optimization problem. </p></li><li><p><code>γ_bases</code> – This needs to be assigned to <code>defaultspinsysbuffer(config.γ_base, Phys),</code>, but replace <code>config.γ_base</code> with your choice of the starting γ parameter. For use with the automated search strategy.</p></li><li><p><code>γ_rates</code> – This needs to be assigned to <code>defaultspinsysbuffer(config.γ_rate, Phys),</code>, but replace <code>config.γ_base</code> with your choice of the rate of increase for the next candidate γ parameter. For use with the automated search strategy. We&#39;ve <code>γ_next = γ_bases*γ_rate^(iter-1)</code>, where iter is the current search iteration. For use with the automated search strategy.</p></li><li><p><code>γ_max_iters</code> – This is similar to θs, but for the maximum allowed iterations in the automated search strategy for γ.</p></li><li><p><code>length_scale_bases</code> and <code>length_scale_rates</code> are similar to <code>γ_bases</code> and <code>γ_rates</code>, but for length_scale = 1/(2*θ).</p></li><li><p><code>min_dynamic_ranges</code> – The sizing of this nested array is the same as θs, but contain the stopping condition dynamic range value for which the kernel bandwidth automated search strategy terminates upon.</p></li></ul><p><strong>Outputs</strong></p><ul><li><p><code>As::Vector{SHType{Float64}}</code> – the simulated resonance intensities and frequencies, sub-system order of coherences, and resonance groups.</p></li><li><p><code>Rs</code> – the partition tree used to generate the resonance groups. For diagnostic purposes.</p></li><li><p><code>MSPs</code> – the spin Hamiltonian matrices and coherence-related quantities. For diagnostic purposes.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/autogen.jl#L106-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMRHamiltonian.serializemixture" href="#NMRHamiltonian.serializemixture"><code>NMRHamiltonian.serializemixture</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function serializemixture(
    As::Vector{SHType{T}},
) where T</code></pre><p>Returns a <code>Dict{Symbol, Any}</code> object, which can then be used with file serialization packages for saving to disk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/serialize.jl#L18-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMRHamiltonian.readbasechemshifts" href="#NMRHamiltonian.readbasechemshifts"><code>NMRHamiltonian.readbasechemshifts</code></a> — <span class="docstring-category">Function</span></header><section><div><p>function readbasechemshifts(P::PhysicalParamsType{T})::Vector{Vector{T}} where T</p><p>Outputs <code>shifts</code>, with index structure [spin system][cs index]. cs is in ppm. Singlet spin systems are at the end of <code>shifts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/conversions/IO_phys.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NMRHamiltonian.extractMEnuclei" href="#NMRHamiltonian.extractMEnuclei"><code>NMRHamiltonian.extractMEnuclei</code></a> — <span class="docstring-category">Function</span></header><section><div><p>extractMEnuclei(     Phys::Vector{PhysicalParamsType{T}}, ) where T</p><p>Outputs: IDs, cs, entry_IDs</p><ul><li>IDs::Vector{Vector{Int}}</li></ul><p>Each entry contains the set of nuclei labels that is associated with the corresponding entry in <code>cs</code>.</p><ul><li>cs::Vector{T}</li></ul><p>Each entry contains the chemical shift entry of a magnetically equivalent group of nuclei. The magnetic equivalent is based on the data stored in the <code>ME</code> field of the entries in Phy`.</p><ul><li>entry_IDs::Vector{Tuple{Int,Int}}</li></ul><p>Each entry contains a pair of integers that is associated with the corresponding entry in <code>cs</code>. The first integer is the molecule entry number. The second is the spin system number that the corresponding nuclei in <code>IDs</code> belongs to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/744b2469a5de1f207f4256b53c85feed2f3a87aa/src/conversions/IO_phys.jl#L238-L252">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../demo_code/">Demo: code walk-through »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 22 July 2023 16:12">Saturday 22 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
