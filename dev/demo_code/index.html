<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Demo: code walk-through · NMRHamiltonian.jl</title><meta name="title" content="Demo: code walk-through · NMRHamiltonian.jl"/><meta property="og:title" content="Demo: code walk-through · NMRHamiltonian.jl"/><meta property="twitter:title" content="Demo: code walk-through · NMRHamiltonian.jl"/><meta name="description" content="Documentation for NMRHamiltonian.jl."/><meta property="og:description" content="Documentation for NMRHamiltonian.jl."/><meta property="twitter:description" content="Documentation for NMRHamiltonian.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NMRHamiltonian.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../api/">Public API</a></li><li class="is-active"><a class="tocitem" href>Demo: code walk-through</a></li><li><a class="tocitem" href="../return_vars/">Demo: return variables</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Demo: code walk-through</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Demo: code walk-through</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/AI4DBiological-Systems/NMRHamiltonian.jl/blob/main/docs/src/demo_code.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Demo:-code-walk-through"><a class="docs-heading-anchor" href="#Demo:-code-walk-through">Demo: code walk-through</a><a id="Demo:-code-walk-through-1"></a><a class="docs-heading-anchor-permalink" href="#Demo:-code-walk-through" title="Permalink"></a></h1><p>For those who prefer working with source files instead of the Julia REPL and notebooks, this demo follows the script <code>examples/simulate.jl</code>, which is derived from <code>examples/simulate_SH.jl</code> in the NMRHamiltonian repository. In this demo, we load the physical chemistry parameters and alias mapping files, then simulate the resonance frequency and intensity, followed by an application of the convex clustering to partition the resonance components into resonance groups.</p><p>First, load the libraries. You can use <code>using</code> (loads NMRHamiltonian into current namespace) or <code>import</code> (loads NMRHamiltonian into its own namespace <code>NMRHamiltonian</code>). We use the latter in this demo.</p><p>The code involving DataDeps, Tar, CodecZlib were developed on <code>DataDeps v0.7.11</code>, <code>Tar v1.10.0</code>, <code>CodecZlib v0.7.3</code>. You might need to modify it if you use a different version of <code>DataDeps</code>.</p><pre><code class="language-julia hljs">import NMRHamiltonian
HAM = NMRHamiltonian # so we don&#39;t need to type NMRHamiltonian. everytime we reference something from this library.


using DataDeps, Tar, CodecZlib

using LinearAlgebra
import PythonPlot as PLT # do Pkg.add(&quot;PythonPlot&quot;) if you&#39;re missing this library.

# the same function for ensuring the dataset at 10.5281/zenodo.8174261 is downloaded.

function getdatapath()::String

    dataset_alias = &quot;AI4DBiological-Systems_NMR_data&quot; # don&#39;t use spaces or &#39;strange&#39; symbols like commas, colons, etc.
    archive_file_name = &quot;nmr_physical_parameters_dataset.tar.gz&quot; # the filename on the data repository that we download.
    url = &quot;https://zenodo.org/record/8174261/files/nmr_physical_parameters_dataset.tar.gz?download=1&quot;

    register(DataDep(&quot;$dataset_alias&quot;,
        &quot;&quot;&quot;
        Dataset: Selected BMRB 1D 1H NMR data and physical chemistry values compiled from literature
        Author: Roy Chih Chung Wang
        License: [Creative Commons Attribution Non Commercial Share Alike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/legalcode)
        DOI: 10.5281/zenodo.8174261

        Description:
        The experiments were downloaded from BMRB,
        The physical chemistry parameters data and sample configuration-related files were collected, organized, converted or manually entered in as JSON files by Roy.
        The physical chemistry parameters, i.e., chemical shift and J-coupling values, are from two sources:
        - GISSMO: (https://gissmo.bmrb.io/ acccessed Mar. 2023). See Dashti, et. al. DOI: 10.1021/acs.analchem.8b02660 and DOI: 10.1021/acs.analchem.7b02884 for more details.
        - From Govindaraju, et. al.&#39;s work: DOI: 10.1002/1099-1492(200005)13:3&lt;129::AID-NBM619&gt;3.0.CO;2-V

        Please cite the data sources and this data repository if you find the contents helpful for your work. See the Zenodo DOI entry for more description.
        &quot;&quot;&quot;,
        url
    ));

    #readdir(datadep&quot;AI4DBiological-Systems NMR data&quot;) # have to manually type out the alias. Does not allow string variable substitution.
    local_dataset_archive_path = @datadep_str(&quot;$dataset_alias&quot;) # call the actual macro to allow string variable substitution.

    # extract archive, then delete. Do this only if archive file still exists.

    root_data_path = joinpath(local_dataset_archive_path, &quot;contents&quot;)
    
    if isfile(joinpath(local_dataset_archive_path, archive_file_name))
        t = @task begin; ispath(root_data_path) || mkpath(root_data_path); end
        schedule(t); wait(t)
    
        #t = @task begin; Tar.extract(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end
        t = @task begin; extractuncompress(joinpath(local_dataset_archive_path, archive_file_name), root_data_path); end
        schedule(t); wait(t)
        rm(joinpath(local_dataset_archive_path, archive_file_name)) # delete the archive file.
    end

    return root_data_path
end

function extractuncompress(src_path, dest_path)
    tar_gz = open(src_path)
    tar = GzipDecompressorStream(tar_gz)
    dir = Tar.extract(tar, dest_path)
    close(tar)
    
    return dir
end

# This was tested in a REPL environment, not a notebook environment. You might need to modify this for notebooks to get it to display the plots.
PLT.close(&quot;all&quot;)
fig_num = 1

# select the AbstractFloat data type you want to use. Anything lower than Float32 will result in numerical precision-related errors in our tests.
#T = Float64
T = Float32</code></pre><p>The variable <code>molecule_entries</code> contain compound aliases. For this demo, any alias in the <code>molecule_name_mapping/select_molecules.json</code> file from <a href="https://zenodo.org/record/8174261">10.5281/zenodo.8174261</a> would work.</p><pre><code class="language-julia hljs">### user inputs.

molecule_entries = [
    &quot;L-Serine&quot;;
    &quot;alpha-D-Glucose&quot;;
    &quot;beta-D-Glucose&quot;;
    &quot;Ethanol&quot;;
    &quot;L-Methionine&quot;;     
    &quot;L-Phenylalanine&quot;;
    &quot;L-Glutathione reduced&quot;;
    &quot;L-Glutathione oxidized&quot;;       
    &quot;Uridine&quot;;
    &quot;L-Glutamine&quot;;
    &quot;L-Valine&quot;;
    &quot;DSS&quot;;
]

# machine values taken from the BMRB 700 MHz 20 mM glucose experiment.
fs, SW, ν_0ppm = HAM.getpresetspectrometer(T, &quot;700&quot;)

## pull the sample coupling values into dictionary structures.
# use DataDeps.jl and Tar.jl to download and extract the sample coupling values.
root_data_path = getdatapath() # coupling values data repository root path

H_params_path = joinpath(root_data_path, &quot;coupling_info&quot;) # folder of coupling values. # replace with your own values in actual usage.


molecule_mapping_root_path = joinpath(
    root_data_path,
    &quot;molecule_name_mapping&quot;,
)
molecule_mapping_file_path = joinpath(
    molecule_mapping_root_path,
    &quot;select_molecules.json&quot;,
)
#molecule_mapping_file_path = joinpath(molecule_mapping_root_path, &quot;GISSMO_names.json&quot;)


# Type ?help HAM.SHConfig for details.
config_SH = HAM.SHConfig{T}(
    coherence_tol = convert(T, 0.01),
    relative_α_threshold = convert(T, 0.005),
    tol_radius_1D = convert(T, 0.1), # strictly between 0 and 1. The lower, the better the approximation, but would a larger partition (i.e. more resonance groups).
    nuc_factor = convert(T, 1.5),
)
</code></pre><p>Now, load the parameters, simulate the resonance components, and partition into resonance groups.</p><pre><code class="language-julia hljs"># read the physical parameters from file, from via the DataDeps routine from &quot;helpers/data.jl&quot;.
Phys = NMRHamiltonian.getphysicalparameters(
    T,
    molecule_entries,
    H_params_path,
    molecule_mapping_file_path;
    unique_cs_atol = convert(T, 1e-6),
)
# You can tweak the J-coupling or chemical shift values of Phys manually if desired, before calling simulate(). We won&#39;t tweak anything in this demo.

# Assemble and eigendecompose the Hamiltonian, get frequencies and intensities for each resonance component, and partition the comonents into resonance groups.
As, MSPs = HAM.simulate(
    Phys,
    molecule_entries,
    fs,
    SW,
    ν_0ppm,
    config_SH,
)</code></pre><p>Now, we&#39;ll plot the absorption Lorentzian spectrum of the simulated resonance frequencies and intensities. We&#39;ll have to make up a T2 relaxation value, which corresponds to the component width.</p><p>We will focus in on the first molecule (change <code>molecule_select = 1</code> to select a different molecule, the molecule names are in <code>molecule_entries</code>) and its first spin system (change <code>spin_system_select = 1</code> to select a different spin system). If <code>T</code> was set to a floating-point data type other than the default one from your operating system&#39;s architecture, then you need to explicitly type-cast each floating-point number to type <code>T</code>, via <code>convert</code>. To find out what the default floating-point data type is, run <code>typeof(1.0)</code>.</p><pre><code class="language-julia hljs">### visualize a target molecule and spin group, given a T-2 decay parameter.
λ0 = convert(T, 3.4) # make up a T-2 decay parameter for this plotting example.
molecule_select = 1
spin_system_select = 1
ppm_offset = convert(T, 0.2) # for display padding.
N_viz = 50000 # this many points to plot



println(&quot;Visualizing $(molecule_entries[molecule_select]) and spin system $(spin_system_select).&quot;)

a = As[molecule_select].αs[spin_system_select]
F = As[molecule_select].Ωs[spin_system_select]

hz2ppmfunc = uu-&gt;(uu - ν_0ppm)*SW/fs # Hz to ppm conversion. This is useful to remember.
ppm2hzfunc = pp-&gt;(ν_0ppm + pp*fs/SW) # ppm to Hz conversion. This is useful to remember.

ΩS_ppm = hz2ppmfunc.( F ./ HAM.twopi(T) ) # convert to radial frequency.
ΩS_ppm_sorted = sort(ΩS_ppm)

u_min = ppm2hzfunc(ΩS_ppm_sorted[1] - ppm_offset)
u_max = ppm2hzfunc(ΩS_ppm_sorted[end] + ppm_offset)

P_min = hz2ppmfunc(u_min)
P_max = hz2ppmfunc(u_max)

P = LinRange(P_min, P_max, N_viz)
U = ppm2hzfunc.(P)
U_rad = U .* HAM.twopi(T)

# absorption Lorentzian.
function evalzerophasecl1Darray(u_rad, αs::Vector{T}, Ωs::Vector{T}, λ::T)::Complex{T} where T &lt;: AbstractFloat

    out = zero(Complex{T})
    for l = 1:length(αs)
        out += evalzerophaseclpartitionelement(u_rad, αs[l], Ωs[l], λ)
    end

    return out
end

function evalzerophaseclpartitionelement(r,
    α::T, Ω::T, λ::T)::Complex{T} where T &lt;: AbstractFloat

    out = α/(λ+im*(r-Ω))

    return out
end

q = uu-&gt;evalzerophasecl1Darray(uu, a, F, λ0)
q_U = q.(U_rad)

# plot.
PLT.figure(fig_num)
fig_num += 1

PLT.plot(P, real.(q_U))

PLT.gca().invert_xaxis()
PLT.ylabel(&quot;real part&quot;)
PLT.title(&quot;spectrum of $(molecule_entries[molecule_select]), spin system $(spin_system_select)&quot;)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« Public API</a><a class="docs-footer-nextpage" href="../return_vars/">Demo: return variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Sunday 19 November 2023 03:48">Sunday 19 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
